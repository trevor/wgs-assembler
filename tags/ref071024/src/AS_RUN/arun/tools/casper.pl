#! /usr/local/bin/perl -w

# Copyright (c) 2004  The Institute for Genomic Research.  All rights reserved.

use strict;
use TIGR::SequenceTiling;
use TIGR::Foundation;
use TIGR::FASTAreader;
use TIGR::AsmLib;
use TIGR::EUIDService;                          # This is for creating links.

our @DEPEND = ( "TIGR::SequenceTiling", "TIGR::Foundation", "TIGR::AsmLib" );
our $VERSION = '1.01';
our $REVISION = '$Revision: 1.1 $';
our $VERSION_STRING = "$VERSION (Build $REVISION)";

our $__HELP_INFO = 
q~NAME
casper - (Celera Assembler Scaffold ParsER) gets the scaffold set 
  from the CA .asm output file.  Contig sizes come from a .FASTA file.
    
SYNOPSIS
casper -l <prefix> [ -r redundancy ] [ -debug level ] [ -h ]

SUMMARY
This program takes assembly data from a Celera Assembler .asm output file,
<prefix>.asm, and renders sequence tiling information from it.  Contig sizes
come from a <prefix>.fasta file.

PARAMETERS
   -l     <prefix>
      Specify a file prefix.

OPTIONS
   -r     <redundancy>
      Specify an acceptable redundancy value for scaffold links.  DEFAULT: 1

   -d
       Make scaffolds out of degenerates. DEFAULT: 0

FILES
   <prefix>.asm
      The .asm output file generated by Celera Assembler.  This is required.

   <prefix>.fasta
      A .fasta file containing the contigs.  This is also required.

EXAMPLE
To convert my.asm into the appropriate sequencing tiling based scaffold 
rendering, do the following.  my.asm and my.fasta are in the current directory.

   casper -l my

CONTACT
Please forward all questions and comments to bits.closure@tigr.org.

Hean Koo,
Dan Kosack
04/09/2004
~;

my $__USAGE_INFO =
q~casper -l <prefix>
-l prefix    Specify a file name prefix.
~;


# Set up TIGR Foundation.
my $tf_obj = new TIGR::Foundation;
$tf_obj->setHelpInfo($__HELP_INFO);
$tf_obj->setUsageInfo($__HELP_INFO);
$tf_obj->setVersionInfo($VERSION_STRING);

# Set up the EUID service.
my $euid_obj = new TIGR::EUIDService;

# General configuration variables.
my %VALID_ORI = ( "I" => 1, "O" => 1, "N" => 1, "A" => 1);
my $INP_SUFFIX = ".asm";
my $FASTA_SUFFIX = ".fasta";
my $OUT_SUFFIX = ".sq.contigs";


# Function definitions.


# This function takes in orientation field "I", "N", "O", "A" and returns
# left and right member strands.  strand = 0  -->,  strand = 1 <-- .
# Rules for ori field:
# N: both left and right forward ori = 0 here
# I: left forward, right reversed (ori = 1)
# A: both reverse
# O (oh): left = reverse right = forward
sub parseOri($) {
   my $ori = shift;
   my $lstrand;
   my $rstrand;

   if ( ! defined ( $VALID_ORI{$ori} ) ) {
      $tf_obj->logError("Orientation \'$ori\' not valid.", 2);
      return undef;
   }
   if ($ori eq "N" || $ori eq "I") {
      $lstrand = 0;
   }
   else {
      $lstrand = 1;
   }
   if ($ori eq "N" || $ori eq "O") {
      $rstrand = 0;
   } 
   else {
      $rstrand = 1;
   }    
   return ($lstrand, $rstrand);
}


# Begin main processing.


MAIN: {
   my $prefix = undef;                         # file name prefix
   my $redun = 1;                              # redundancy score
   my $use_degen=0;
   my $options_ok = $tf_obj->TIGR_GetOptions(
                                             "l=s" => \$prefix, 
                                             "r=i" => \$redun,
					     "d"   => \$use_degen
                                            );

   # option checks
   if ( ! $options_ok ) {
      $tf_obj->logError("Command line parsing failed.", 3);
      $tf_obj->printUsageInfoAndExit();
   }
   if ( ! defined ( $prefix ) ) {
      $tf_obj->logError("Please supply a -l <prefix>.", 3);
      $tf_obj->printUsageInfoAndExit();
   }

   # Construct the input file name.
   my $asmfile = $prefix . $INP_SUFFIX;
   if ( ! open ASM, $asmfile ) {
      if ( ! defined ( $asmfile ) ) {
         $asmfile = "<undefined>";
      }
      $tf_obj->bail("Failed to open .asm input file \'$asmfile\'.");
   }
   else {
      $tf_obj->logLocal("Opened .asm input file \'$asmfile\'.", 3);
   }

   # Construct the contig FASTA file.
   my $fastafile = $prefix . $FASTA_SUFFIX;
   my $f_obj = new TIGR::FASTAreader $fastafile;
   if ( ! defined ( $f_obj ) ) {
      $tf_obj->bail("Failed to open FASTA input file \'$fastafile\'.");
   }

   # Set up the output file name.
   my $scctgs_file = $prefix . $OUT_SUFFIX;
   if ( ! open ( OUT, ">" . $scctgs_file ) ) {
      $tf_obj->bail("Failed to open file \'$scctgs_file\' for writing.");
   }

   # Begin the parsing.
   my %scaffold;  # Holds the scaffold pairs, from which the order is derived.
   my %degens;    # Hold degenerate scaffolds.
   my @clk;       # Holds contig link records.
   my %ctgsize;   # Holds contig sequence (ungapped) length.
   $tf_obj->logLocal("Parsing input file \'$asmfile\'.", 1);
   while ( defined ( my $record = getCARecord(\*ASM) ) ){
      my ($type, $fields, $recs) = parseCARecord($record);
      my $scount = 0;
      $tf_obj->logLocal("Got CA record type \'$type\'.", 2);
      # Get the scaffold records.
      if ( $type eq "SCF" ) {
         my $id = getCAId($$fields{"acc"});
         $tf_obj->logLocal("Got scaffold pair id \'$id\'.", 3);
         for (my $i = 0; $i <= $#$recs; $i++){
            my ($srec, $sfield, $srecs) = parseCARecord($$recs[$i]);
            $scaffold{$id}->{$scount} = $sfield;
            $scount++;
         }
      }
      # Get the degenerate scaffold records. 

      # Daniela Puiu: Fen 26th 2007 added $use_degen
      if ( $use_degen and $type eq 'DSC' ) {
         my $id = $$fields{"acc"};
         my $ctg = $$fields{'ctg'};
         $degens{$id} = $ctg;
      }
      # Get the link records.
      if ( $type eq "CLK" ) {
         if ( $fields->{'num'} >= $redun ) {
            push @clk, $fields;
         }
      }
      # Get the contig records,
      if ( $type eq "CCO" ) {
         my $acc = $fields->{'acc'};
         my $id;
         if ( $acc =~ /\((\d+)\,\d+\)/ ) {
            $id = $1;
            $tf_obj->logLocal("Got CCO record id \'$id\'.", 4);
         }
         if ( $id !~ /\d+/ ) {
            $tf_obj->bail("Error getting contig id from \'$acc\'.");
         }
         my $fseq = $f_obj->getRecordByIdentifier($id);
         if ( ! defined ( $fseq ) ) {
            $tf_obj->logError("Cannot find \'$id\' in FASTA file!", 4);
         }
         $ctgsize{$id} = $fseq->size();
      }
   }
   $tf_obj->logLocal("Finished parsing CA .asm file.", 1);
   if ( ! close(ASM) ) {
      $tf_obj->bail("Could not close \'$asmfile\' handle!");
   }

   $tf_obj->logLocal("Going to create sequence tiling records.", 1);
   my $draft = new TIGR::SequenceTiling;       # Draft sequence tiling.
   my $final = new TIGR::SequenceTiling;       # Final sequence tiling.
   my %sc_len = ();                            # Keep track of length! 
   foreach my $sc_id ( sort { $a <=> $b } keys %scaffold ) {
      $tf_obj->logLocal("Examining scaffold \'$sc_id\'.", 2);
      $sc_len{$sc_id} = 0;
      # Log a scaffold in the draft.
      if ( ! $draft->addSequence($sc_id, 1000000000, "SCAFFOLD") ) {
         $tf_obj->logError("Failed to add scaffold \'$sc_id\' to draft.", 3);
         next;
      }
      my $offset = 0;  # Track offset for all contigs in the scaffold.
      # Data is keyed by a counter for each ctg pair in the scaffold order.
      my $data = $scaffold{$sc_id};  
      my @key_arr = keys %{$data};
      foreach my $key_idx ( sort { $a <=> $b } keys %{$data} ) {
         # Pairs keyed by pair attributes like "ori", "ct1", "ct2", etc...
         my $pairs = $data->{$key_idx};  
         my $lctg = $pairs->{'ct1'};
         my $rctg = $pairs->{'ct2'};
         my $ori  = $pairs->{'ori'};
         my $mea  = int($pairs->{'mea'});      # Get the mean gap size.
         my $lctg_len = $ctgsize{$lctg};
         my $rctg_len = $ctgsize{$rctg};
         my ( $lstrand, $rstrand ) = parseOri($ori);

         $tf_obj->logLocal("Got pair position \'$key_idx\': " .
            "\'$lctg\' , \'$rctg\' offset = \'$offset\'.",4);
         # Add left contig to draft.
         if ( ! $draft->addTile($sc_id, $lctg, $lctg_len, $offset, $lstrand,
                                "CONTIG", "") ) {
            $tf_obj->logLocal("Failed to add contig \'$lctg\' to scaffold " .
               "\'$sc_id\'.", 5);
            next;
         }

         # Increment the offset. 
         $offset += $lctg_len + $mea;
         # Increment scaffold length.
         if ( $sc_len{$sc_id} <= $offset ) {
            $sc_len{$sc_id} = $offset;
         }

         # Log all data associated with this ctg pair.
         foreach my $i (keys %{$pairs}) {
            $tf_obj->logLocal("$i = $pairs->{$i}",9);
         }

         # Print the record for the right-most contig.
         if ( ( $key_idx == $#key_arr ) && ( $lctg != $rctg) ) {
            if ( ! $draft->addTile($sc_id, $rctg, $rctg_len, $offset, 
                                   $rstrand, "CONTIG", "") ) {
               $tf_obj->logLocal("Failed to add contig \'$lctg\' to scaffold ".
                  "\'$sc_id\'.", 5);
               next;
            }
            $tf_obj->logLocal("Added contig \'$rctg\' to scaffold " .
               "\'$sc_id\'.", 4);
            # Increment scaffold length.
            if ( $sc_len{$sc_id} < ( $offset + $rctg_len ) ) {
               $sc_len{$sc_id} = $offset + $rctg_len;
            }
         }
      } # foreach pair
      # Add the draft scaffold to the final scaffold set.
      if ( ! $final->addSequence($sc_id, $sc_len{$sc_id}, "SCAFFOLD") ) {
         $tf_obj->logError("Failed to add scaffold \'$sc_id\' to final.", 3);
         next;
      }
      # Add each tile.
      foreach my $ctg_id ( @{ $draft->getSequenceTiles($sc_id) } ) {
         $tf_obj->logLocal("Processing contig \'$ctg_id\'.", 3);
         my $len = $draft->getTileLength($sc_id, $ctg_id);
         my $offset = $draft->getTileOffset($sc_id, $ctg_id);
         my $strand = $draft->getTileStrand($sc_id, $ctg_id);
         my $reference = $draft->getTileReference($sc_id, $ctg_id);
         my $tile_type = $draft->getTileType($sc_id, $ctg_id);
         if ( ! $final->addTile($sc_id, $ctg_id, $len, $offset, $strand, 
                                $tile_type, $reference) ) {
            $tf_obj->logError("Failed to add contig \'$ctg_id\' to scaffold " .
               "\'$sc_id\'.", 4);
            next;
         }
         $tf_obj->logLocal("Added contig \'$ctg_id\' to scaffold " .
            "\'$sc_id\'.", 3);
      }
   } # foreach scaffold
   # Add degenerate scaffolds.
   foreach my $scaff_id ( keys %degens ) {
      my $ctg_id = $degens{$scaff_id};
      my $ctg_len = $ctgsize{$ctg_id};
      my $scf_len = $ctg_len;
      if ( ! defined ( $final->addSequence($scaff_id, $scf_len, "SCAFFOLD"))) {
         $tf_obj->bail("Cannot add degen. scaffold \'$scaff_id\' to set.");
      }
      if ( ! defined ( $final->addTile($scaff_id, $ctg_id, $ctg_len, 0,
                       0, "CONTIG", "") ) ) {
         $tf_obj->bail("Cannot add contig \'$ctg_id\' to degen. scaffold " .
            " \'$scaff_id\'.");
      }
   }
    
   # Print the scaffolds to the output stream.
   if ( ! $final->toStream(\*OUT) ) {
      $tf_obj->bail("Failed to print scaffolds to output stream.");
   }
   if ( ! close(OUT) ) {
      $tf_obj->bail("Failed to close output stream.");
   }
   exit 0;
}
