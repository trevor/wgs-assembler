
#if 1

//  The CheckForContigs() that is currently in CIscaffold_Cleanup_CGW.c

#else

int CheckForContigs(ScaffoldGraphT *sgraph,
                    CDS_CID_t cid, CDS_CID_t sid,
                    LengthT offsetAEnd, LengthT offsetBEnd){
  ChunkInstanceT *CI = GetGraphNode(sgraph->RezGraph, cid);
  GraphEdgeIterator   edges;
  CIScaffoldT *scaffold = GetGraphNode(sgraph->ScaffoldGraph, sid);
  CIEdgeT *edge;
  IntElementPos pos, *basePos;
  CDS_CID_t cidOther;
  int numEdges = 0;
  int numContainmentEdges = 0;
  int numAEdges = 0;
  int numBEdges = 0;

  fprintf(GlobalData->stderrc,"* CheckForContigs scaffold " F_CID "\n", scaffold->id);
  CI->scaffoldID = NULLINDEX; // test!!!

  if(ContigPositions == NULL){
    ContigPositions = CreateVA_IntElementPos(10);
  }
  ResetVA_IntElementPos(ContigPositions);

  pos.type = AS_CONTIG;
  pos.ident = cid;
  // Orientation of inserted chunk is always A_B
  pos.position.bgn = 0;
  pos.position.end = CI->bpLength.mean;
  AppendIntElementPos(ContigPositions, &pos);
  basePos = GetIntElementPos(ContigPositions,0);


  /* Look for overlap edges to Contigs already in this scaffold.
     The edges must be 'mustOverlap' AND they must overlap by mean
     contig position...otherwise, don't contig them.
  */
  InitGraphEdgeIterator(sgraph->RezGraph, cid, 
			ALL_END, ALL_EDGES, 
			GRAPH_EDGE_DEFAULT,
			&edges); 
  while (edge = NextGraphEdgeIterator(&edges)) {
    ChunkInstanceT *CIOther;
    int end;
    CDS_COORD_t overlap;
    ChunkOrientationType orient = GetEdgeOrientationWRT(edge, cid);

    assert(edge != NULL);


    if(cid == edge->idA)
      cidOther = edge->idB;
    else
      cidOther = edge->idA;

    CIOther = GetGraphNode(sgraph->RezGraph, cidOther);
    
    if(CIOther->scaffoldID != sid || !isOverlapEdge(edge) ||
       isSingletonOverlapEdge(edge))
      continue;
    
      overlap = IntervalsOverlap(CIOther->offsetAEnd.mean, CIOther->offsetBEnd.mean,
					 CI->offsetAEnd.mean, CI->offsetBEnd.mean,
					 -15000);

      //      assert(0/*Why Does overlap > 0 screw this up???? */);

    fprintf(GlobalData->stderrc,"* other scaffold id = " F_CID " (" F_CID ") mustOverlap:%d mean:%g std:%g overlap:" F_COORD " [%g,%g] [%g,%g]\n",
	    CIOther->scaffoldID, sid,isMustOverlapEdge(edge),   edge->distance.mean, sqrt(edge->distance.variance), overlap,
	    CIOther->offsetAEnd.mean, CIOther->offsetBEnd.mean,
	    CI->offsetAEnd.mean, CI->offsetBEnd.mean);
    if(/*(overlap > 0) && */ 
       (isMustOverlapEdge(edge) ||
       (3 * sqrt(edge->distance.variance) <  -edge->distance.mean))){

      numEdges++;
      switch(orient){
      case AB_BA:
	end = B_END;
	pos.ident = cidOther;
	pos.position.end = basePos->position.end + edge->distance.mean;
	pos.position.bgn = pos.position.end + CIOther->bpLength.mean;
	AppendIntElementPos(ContigPositions, &pos);
	numBEdges++;
	break;

      case AB_AB:
	end = B_END;
	pos.ident = cidOther;
	pos.position.bgn = basePos->position.end + edge->distance.mean;
	pos.position.end = pos.position.bgn + CIOther->bpLength.mean;
	AppendIntElementPos(ContigPositions, &pos);
	numBEdges++;
	break;
      case BA_BA:
	end = A_END;
	pos.ident = cidOther;
	pos.position.end = basePos->position.bgn - edge->distance.mean;
	pos.position.bgn = pos.position.end - CIOther->bpLength.mean;
	AppendIntElementPos(ContigPositions, &pos);
	numAEdges++;
	break;

      case BA_AB:
	end = A_END;
	pos.ident = cidOther;
	pos.position.bgn = basePos->position.bgn - edge->distance.mean;
	pos.position.end = pos.position.bgn - CIOther->bpLength.mean;
	AppendIntElementPos(ContigPositions, &pos);
	numAEdges++;
	break;
      default:
	assert(0);
      }
      fprintf(GlobalData->stderrc,"* (" F_CID "," F_CID ",%c) [" F_COORD "," F_COORD "]\n",
	      cid, cidOther, orient, pos.position.bgn, pos.position.end);

      if(edge->flags.bits.hasContainmentOverlap)
	numContainmentEdges++;

      fprintf(GlobalData->stderrc,"* Inserting CI " F_CID " in scaffold " F_CID " implies contigging with CI " F_CID " by %s on %c end\n",
	      cid, sid, cidOther, 
	      (edge->flags.bits.hasContainmentOverlap?"Containment":"Overlap"),
	      (end == A_END? 'A':'B'));
      PrintGraphEdge(GlobalData->stderrc,sgraph->RezGraph, " ", edge, cid);
    }
  }

  if(numEdges >= 0){
    fprintf(GlobalData->stderrc,"* Inserting cid " F_CID " into scaffold " F_CID " implied %d contigging operations (%d contains)(%d A, %d B)\n",
	    cid, sid, numEdges, numContainmentEdges, numAEdges, numBEdges);
  }


  if(GetNumIntElementPoss(ContigPositions) > 1)
    { 

      return CreateAContigInScaffold(scaffold, ContigPositions, offsetAEnd, offsetBEnd);

    }
/* This path takes care of the case where there is no contigging
   implied by this insertion */

  return FALSE;

}

#endif
