{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
{\f36\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier (PCL6);}{\f68\froman\fcharset238\fprq2 Times New Roman CE;}{\f69\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f71\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f72\froman\fcharset162\fprq2 Times New Roman Tur;}{\f73\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f74\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f75\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f76\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li0\ri0\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\*\cs10 
\additive \ssemihidden Default Paragraph Font;}{\*\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{\s15\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 header;}{\s16\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext16 footer;}{
\s17\qj \li360\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17 Indent;}{\s18\ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext18 Myheader;}{\*\cs19 \additive \ul\cf2 \sbasedon10 Hyperlink;}{\s20\ql \fi360\li360\ri0\widctlpar\faauto\adjustright\rin0\lin360\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext20 Body Text 2;}{\s21\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext21 Body Text;}{
\s22\ql \fi360\li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext22 Body Text Indent 2;}{\*\cs23 \additive \ul\cf12 \sbasedon10 FollowedHyperlink;}}{\*\listtable
{\list\listtemplateid1322393364\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'03(\'00);}{\levelnumbers\'02;}\fbias0 \fi-360\li1080\jclisttab\tx1080\lin1080 }{\listname 
;}\listid197663996}{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fbias0 \fi-360\li360\jclisttab\tx360\lin360 }
{\listname ;}\listid225839228}{\list\listtemplateid-850244900\listsimple{\listlevel\levelnfc1\levelnfcn1\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'03(\'00);}{\levelnumbers\'02;}\fbias0 \fi-720\li1080
\jclisttab\tx1080\lin1080 }{\listname ;}\listid470094150}{\list\listtemplateid67698689\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 
\fi-360\li360\jclisttab\tx360\lin360 }{\listname ;}\listid582495134}{\list\listtemplateid-1753947694\listsimple{\listlevel\levelnfc3\levelnfcn3\leveljc0\leveljcn0\levelfollow0\levelstartat15\levelspace0\levelindent0{\leveltext\'03(\'00);}{\levelnumbers
\'02;}\fbias0 \fi-540\li900\jclisttab\tx900\lin900 }{\listname ;}\listid642585575}{\list\listtemplateid67698689\listsimple{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext
\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360\lin360 }{\listname ;}\listid1216311041}{\list\listtemplateid1322393364\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0
\levelindent0{\leveltext\'03(\'00);}{\levelnumbers\'02;}\fbias0 \fi-360\li1080\jclisttab\tx1080\lin1080 }{\listname ;}\listid1413426012}{\list\listtemplateid67698713\listsimple{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace0\levelindent0{\leveltext\'03(\'00);}{\levelnumbers\'02;}\fi-360\li360\jclisttab\tx360\lin360 }{\listname ;}\listid2100133172}}{\*\listoverridetable{\listoverride\listid225839228\listoverridecount0\ls1}{\listoverride\listid197663996
\listoverridecount0\ls2}{\listoverride\listid1216311041\listoverridecount0\ls3}{\listoverride\listid1413426012\listoverridecount0\ls4}{\listoverride\listid470094150\listoverridecount0\ls5}{\listoverride\listid642585575\listoverridecount0\ls6}
{\listoverride\listid582495134\listoverridecount0\ls7}{\listoverride\listid2100133172\listoverridecount0\ls8}}{\*\rsidtbl \rsid8215531\rsid10617789}{\*\generator Microsoft Word 10.0.4524;}{\info{\title MODULE DOCUMENTATION GUIDELINES (draft)}
{\author Perkin Elmer}{\operator Jason Miller}{\creatim\yr1999\mo1\dy22\hr16\min40}{\revtim\yr2004\mo2\dy9\hr15\min56}{\printim\yr1999\mo1\dy12\hr16\min47}{\version10}{\edmins234}{\nofpages9}{\nofwords4025}{\nofchars22949}
{\*\company The Perkin Elmer Corporation}{\nofcharsws26921}{\vern16475}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot\nolnhtadjtbl\rsidroot8215531 \fet0\sectd \linex0\endnhere\sectdefaultcl\sftnbj {\header \pard\plain \s15\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\fs24\insrsid10617789 Assembly Team Doc\tab \tab Celera CONFIDENTIAL
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\fs24\insrsid10617789 CHUNK GRAPH WALKER DESIGN (draft)
\par 
\par }\pard \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\fs24\insrsid10617789 Overview
\par }{\fs24\insrsid10617789 
\par The goal of chunk graph walking is to find a consistent set of paths through the chunk graph which maximizes the inclusion of chunks and essential overlap edges while minimizing the number of clone mate constraints which are violated. The chief strategy w
i
ll be to use clone mates to navigate the chunk graph. This means that clone mate information will be used to choose between alternate branches in the chunk graph for any given path. The chunk graph will be extended to include mate edges between every pair
 
of chunks which contain one member each of a clone mate pair. There will not exist a mate edge for every clone mate pair because a consistent set of clone mate pairs between the same pair of chunks will be combined into a single weighted mate edge. The ma
t
e edge encodes the number of clone mate pairs consistent with this edge, the implied orientation of the chunks (can use the same notation as for overlap edges), and the possible distance range between the chunks (this can be either an implied overlap or g
a
p). The possible distance range is determined by taking the intersection of possible distance ranges for each clone mate pair contributing to the mate edge (the distance range for each clone mate pair is a result of the clone length distribution for a giv
e
n library as initially defined to the system in a distance message). The reader should note that there may be more than one mate edge between a pair of chunks if the set of clone mate pairs between the chunks are not all mutually consistent. A key compone
n
t of the strategy is that confirmed edges are highly reliable. A confirmed mate edge is a mate edge with at least two underlying clone mate pairs. An unconfirmed mate edge can also be confirmed by a consistent overlap edge in the underlying chunk graph. A
 further extension of confirmation is that finding a path of any combination of overlap and mate edges which is consistent with another unconfirmed mate edge confirms that mate edge.
\par 
\par At any point in the chunk graph walk the problem can be viewed as making 
a path extension decision in one direction based on the mate and overlap edges going in that direction from the current partial path. The algorithm for choosing the path extension will be primarily greedy relying on the assumption that confirmed mate edge
s
 are highly reliable. Unfortunately, the path extension algorithm also relies upon being able to label chunks as repetitive (used in more than one path) or unique (used in only one path) and this labeling is not as robust as confirmed mate edges. The init
i
al labeling of the chunks will rely on a combination of arrival rate statistics within the chunk and type and position of branch points within the chunk. The arrival rate statistic gives a precise maximum likelihood ratio for the probability of a chunk be
i
ng unique versus repetitive but the separability of this statistic is poor for short chunks and low coverage levels. The branch point patterns are more qualitative but help when the arrival rate is ambiguous. It is not clear what level of coverage will be
 necessary for this algorithm to have much success. It is also not clear how good the chunk labeling needs to be or what the ratio of false positive to false negative unique chunk labeling will be optimal for the algorithm.
\par 
\par The path extension algorithm use
s the confirmed mate edges and chunk labeling in the following way: first only the mate edges out of unique chunks are used because repeat chunks can be on multiple paths and hence have mate edges to multiple paths which does not help us extend the curren
t
 path with confidence, second only confirmed mate edges are used to extend the path because these are highly reliable, and finally, if confirmed mate edge conflicts arise then the algorithm attempts to backtrack and relabel the chunk causing the conflict 
from unique to repeat. The seeding chunk for path extension will be the chunk with the highest uniqueness score because the algorithm works best starting from correctly labeled unique chunks.
\par 
\par Each chunk will also be checked for internal clone mate consistency and suspicious chunks will be relegated to the end of the queue for path extension.
\par 
\par }{\b\fs24\insrsid10617789 Memory Usage
\par }{\fs24\insrsid10617789 
\par The major memory consuming data structures will be for the extended chunk graph which includes chunks, overlap edges, and mate edges.
\par 
\par }{\b\fs24\insrsid10617789 Interface
\par }{\fs24\insrsid10617789 
\par The inp
ut to the chunk graph walker consists of messages/data: clone mate messages specifying clone mate pairs, distance messages specifying the statistics of clone lengths for a given library, and chunk graph messages of types to be determined specifying the ch
u
nk graph (chunks and chunk overlap edges). The chunk information must specify the location within a chunk of every fragment (this is complicated if fragments are allowed to be in multiple chunks). In addition, information about chunk uniqueness such as th
e maximum likelihood arrival rate statistic and branch points must either be explicitly passed to or computed by the chunk graph walker.
\par 
\par The structure of the chunk messages is still being defined but more importantly the content of the chunk needs to be sp
ecified. The chunk could simply be defined by the set of essential edges from the overlap graph internal to the chunk. The chunk graph walker needs to have coordinate ranges for the endpoints of all the fragments making up a chunk (coordinate ranges due t
o the uncertainty of the final alignment). These coordinate ranges can be passed to or computed by the chunk graph walker.
\par 
\par The output of the chunk graph walker is a set of paths through the chunk graph. The chunk graph walker must also pass through any rel
evant messages to the next module such as clone mate messages. Currently, the next module is the repeat separator/resolver.
\par 
\par }{\b\fs24\insrsid10617789 Design
\par }{\fs24\insrsid10617789 
\par For now it is assumed that the chunk graph builder is responsible for the following steps: maximum likelihood ratio of arri
val rate statistic for chunk uniqueness labeling, branch point labeling of chunks, and coordinate range representation of fragment positions within chunks. This leaves three major tasks for the chunk graph walker: building the extended chunk graph by addi
ng mate edges, checking for clone mate consistency within chunks, and finding paths through the chunk graph.
\par 
\par Building the extended chunk graph should be straightforward. For each pair of chunks which contain one
 member each of a clone mate pair construct a mate edge between these chunks. The mate edge specifies the orientation of the chunks with respect to each other and the distance range between the chunks. There may exist more than one clone mate pair between
 
a given pair of chunks. In this case the clone mate pair must be checked for consistency with any existing mate edge. If it is consistent then the mate edge is modified to include the new clone mate pair, otherwise a new mate edge is created. Clone mate p
a
irs are consistent for chunk pairs if they give the same chunk orientation and their distance ranges overlap. A special note is needed for fragments which may be placed in multiple chunks. These fragments only occur because they are contained in at least 
o
ne other fragment and are part of a repeat. These fragments should not be used in the determination of mate edges because they violate the assumptions made later about mate edges (one such assumption is that all mate edges emanating from a unique chunk wi
ll terminate on chunks along a single consistent path with the exception of chimeric mate edges \endash  we can obviously not rely on this being true for any mate edge based on a fragment which can be placed in multiple chunks).
\par 
\par Checking for clone mate consistenc
y within a chunk is also straightforward. Each fragment within a chunk whose clone mate should lie within the chunk but does not is an inconsistency ( this can be extended to include clone mates which should overlap with the chunk but do not). A threshold
 
based on a probabilistic model of how often clone mate constraints should be violated due to chimeric clones will be used to label inconsistent clones. In addition, a different threshold can be used for two special cases: inconsistent clones in the same r
egion and confirmed inconsistent clones (these are confirmed mate edges which should have an overlap edge between the same pair of chunks but do not).
\par 
\par The first step in constructing a path through the chunk graph can also be thought of as a verification of a chunk\rquote 
s labeling as a unique chunk. This could in fact be an initial pass through all of the chunks if an efficient way to store and access the results is used so that the computation does not have to be repeated. This chunk verification is a check of t
he consistency of the mate edges emanating from a single chunk based on the assumption that the chunk is unique which infers that all nonchimeric mate edges should fall along a single path. In practice this means that all confirmed mate edges (highly unli
kely to be chimeric) must form a consistent path and that there also not be too many unconfirmed mate edges (using a statistical model of chimeric clone mate pairs) that do not fall along this consistent path.
\par 
\par A path can be thought of in at least two ways:
 as an ordering (possibly partial) of chunks and/or a range of coordinates for each chunk relative to some initial chunk which implies an ordering. The initial path construction step/chunk uniqueness verification can be thought of as constructing a coordi
nate range representation of a path relative to the initial chunk based on mate edges incident to that chunk. We fix the starting coordinate of the initial chunk s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  equal to 0 and the final coordinate f}
{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  to a range based on the length and length variation of the initial chunk. For each chunk j with a mate edge to initial chunk i we can calculate coordinates s}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789  and f}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  based on the length and variation of mate edge m}{\fs24\sub\insrsid10617789 ij}{\fs24\insrsid10617789  and chunks c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 
 and c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 . We can sort this list of start and final coordinates for each chunk by the start coordinate and then quickly search if any chunks have a potential overlap by checking for each c}{
\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  with s}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  and f}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  if there exists a c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  with s}{
\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  where s}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  <= s}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  < f}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  \endash 
 min_overlap. We can then quickly check for the existence of these potential overl
ap edges in the chunk graph. We will also need to explicitly check for overlaps missed by the overlapper module at this point. For each overlap found we will form an extended chunk (or echunk) which will have similar properties to a chunk but which will a
lso have internal coordinates that specify where each constituent chunk falls within the echunk. The relative coordinates of the echunk within the path will be inferred from the constituent chunks relative coordinates.
\par 
\par Any chunks which had unconfirmed mate edges with the initial chunk c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 
 but were found to have at least one consistent overlap with another chunk are now considered to be confirmed as well (so by definition all echunks are confirmed). There is one important exception to this rule. If an overlap with the initial chunk c}{
\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 
 would not occur if the fragment reads which formed the unconfirmed mate edge were removed then this mate edge is still unconfirmed (and the echunk formed by this overlap will be dissolved). The reason for this is that there must 
be independent confirmation to label a mate edge as confirmed or in other words a single clone is not allowed to confirm a mate edge. We will now check to see if all confirmed chunks (chunks with confirmed mate edges to c}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789 ) and echunks (confirmed via overl
ap) can be placed consistently along a single path (note we will not worry about conflicts with unconfirmed chunks unless the number of conflicts becomes too high). For the rest of this discussion we will not distinguish between chunks and echunks except 
w
hen necessary and the words chunk and chunks should be considered to mean both chunks and echunks unless explicitly specified otherwise. The problem now is to see if a set of chunks with a given set of starting and final range coordinates and minimum leng
t
h coordinates which are known to not overlap by more than some minimum overlap length can be placed (coordinates assigned) with out violating any of these constraints. This problem is easy if the coordinate ranges of all the chunks are never contained in 
another coordinate range \endash  for c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  if s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < s}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789  then f}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < f}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  because we can just start with the smallest s}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  and for each s}{
\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  in increasing order shift the chunk c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  as far left as possible without causing an overlap we know does not exist until we have a cons
istent set of coordinates for all of the chunk or we violate the f}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  constraint for some chunk. For contained coordinates where chunk c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789 \rquote 
s coordinate range contains chunk c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 \rquote s coordinate range the choice is not so simple because there are four possibilities
 in trying to order the two chunks: first there may be no way to place the two chunks without violating the no overlap rule, second we may be able to place chunk c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  either to the left or the right of c}{
\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 , third we can place c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  only to the left of c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 , or fourth we can place c}{\fs24\sub\insrsid10617789 
k}{\fs24\insrsid10617789  only to the right of c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 . We can proceed for the four cases as follows: case one we know we have a conflict and can quit, case two we choose the placement of c}{
\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  which results in the leftmost placement of the two chunks combined which should always be placing c}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  to the left of c}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789 , case three and case four we have no choice since only one placement is valid. The real problem arises when we have nested contains and we need to keep track of all possible choices for case two in case we need to
 backtrack based on a later constraint. The way to implement this backtracking is to satisfy the most deeply nested constraints first and work our way up. In theory this could lead to an exponential explosion but in practice the amount of nesting should b
e minimal and case two nesting should be even rarer.
\par 
\par A better way to formulate the above algorithm is as a partial ordering on the chunks followed by a topological sort. First for each chunk c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  we see if c}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789  can possibly be placed before each chunk c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  based on their range coordinates ((s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 ,f}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789 ) and (s}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 ,f}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 )), minimum sizes (m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  and m}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789 ), and minimum allowed overlap (min_overlap). If (s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  + m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  \endash  min_overlap) < (f}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789  \endash  m}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 ) then we will define c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789 
. If when we compute this we find that neither c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  nor c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789  then we have a conflict and cannot find a single consistent path. If we find both c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  and c}{\fs24\sub\insrsid10617789 j}{
\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  then we cannot determine the relative order between these two chunks and we ignore both relations. Otherwise, either c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < c
}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  or c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  < c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  but not both a
re true and we have defined a partial order on the chunks. We now proceed basically as outlined above, where we start with the leftmost chunk and shift it as far as possible to the left then shift the next chunk as far as possible to the left without prod
u
cing an overlap conflict and make sure as we proceed that we do not have a coordinate range conflict. If no conflicts arise there does exist a single consistent path for this set of chunks. The only complication is when the topological sort does not produ
c
e a total ordering but has ambiguity between some chunks. For these unordered sets of chunks we need to find the leftmost unconflicted ordering. We could just check each possible permutation of the set of chunks and keep the leftmost unconflicted one. Pre
f
erably, we can predict an ordering of the permutations by which will give the leftmost result and then check them in this order for conflicts so that when we find an unconflicted one we can quit. Several rules hold and can be proved by contradiction. Firs
t some terminology, relabel the topologically unordered set of chunks from 1 to n such that s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  <= s}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789  <= \'85 <= s}{\fs24\sub\insrsid10617789 n}{
\fs24\insrsid10617789  and then use the same conventions as before and define P = p}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789 p}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 \'85p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 
 to be a permutation of the chunks. We will say P is unconflicted if by doing the leftmost shifting test on P we do not have any overlap or range conflicts and we will call the resulting rightmost coordinate of this leftmost compaction P}{
\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789 . For any unconflicted P where p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  not equal to c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  and P}{\fs24\sub\insrsid10617789 f}{
\fs24\insrsid10617789  <= f}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  we can construct an unconflicted P\rquote  with P\rquote }{\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789  = P}{\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789 
. This is easy to see by just taking p}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  = c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  and constructing P\rquote  = p}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789 p}{
\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 \'85p}{\fs24\sub\insrsid10617789 k-1}{\fs24\insrsid10617789 p}{\fs24\sub\insrsid10617789 k+1}{\fs24\insrsid10617789 \'85p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 p}{\fs24\sub\insrsid10617789 k
}{\fs24\insrsid10617789 . We can slide p}{\fs24\sub\insrsid10617789 k+1}{\fs24\insrsid10617789 \'85p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  by m}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 
 to left because no starting coordinate violations will occur because s}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  is the largest starting coordinate for this set of chunks and p}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  = c}{
\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  so p}{\fs24\sub\insrsid10617789 k+1}{\fs24\insrsid10617789 \'85p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  will all have start positions > s}{\fs24\sub\insrsid10617789 n}{
\fs24\insrsid10617789 . Now we just tack p}{\fs24\sub\insrsid10617789 k}{\fs24\insrsid10617789  onto the end which will not violate the final coordinate constraint for c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  because P}{
\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789  <= f}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 . Recognizing that any P ending in p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  = c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 
 has P}{\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789  <= f}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 , we can conclude that any P ending in p}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  = c}{\fs24\sub\insrsid10617789 n}{
\fs24\insrsid10617789  is more leftmost than one that does not. By induction we can make the argument that you always want to try the next untried permutation which \endash  well maybe not I\rquote m still working on it. It is clear tha
t if you can order c}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789 c}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 ...c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  such that s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  <= s}
{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789  <= \'85 <= s}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  and f}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  <= f}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789  <= \'85 <= f}{
\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  then the identity permutation P = c}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789 c}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 ...c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789 
 always has the smallest P}{\fs24\sub\insrsid10617789 f}{\fs24\insrsid10617789  \endash  the proof by contradiction is very similar to the one above.
\par 
\par There is one obvious decomposition of the problem which is to split the path anywhere where there is guaranteed to be a gap. Formally, if we order the chunks such that s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  <= s}{\fs24\sub\insrsid10617789 
2}{\fs24\insrsid10617789  <= \'85 <= s}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  then we can partition the problem into two subproblems c}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789 c}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 
...c}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  and c}{\fs24\sub\insrsid10617789 j+1}{\fs24\insrsid10617789 c}{\fs24\sub\insrsid10617789 j+2}{\fs24\insrsid10617789 ...c}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  when for all f}{
\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  i <= j, f}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  \endash  min_overlap < s}{\fs24\sub\insrsid10617789 j+1}{\fs24\insrsid10617789 
. Once you have decomposed the problem in this way as far as possible and for the subproblem again renumbered and ordered the chunks such that s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  <= s}{\fs24\sub\insrsid10617789 2}{\fs24\insrsid10617789 
 <= \'85 <= s}{\fs24\sub\insrsid10617789 n}{\fs24\insrsid10617789  there are some obvious constraints/bounds on being able to find an unconflicted solution. One bound is that s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  + the sum of m}{
\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  over i = 1 to n \endash  (n-1) * min_overlap < max (f}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 
). We can actually order the final coordinates in decreasing order and apply this bound recursively after removing the chunk with the largest final coordinate each time. This bound actually has to hold for any subset of the chunks and might be worth compu
t
ing for every contiguous subset. The DAG implied by the partial order defined above without transitive edges removed can be used to compute this bound at all interior nodes for ordered subsets. We can try to decide on the tightest bound for any subset of 
chunks. One observation is that if s}{\fs24\sub\insrsid10617789 1}{\fs24\insrsid10617789  + the sum of m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  over i = 1 to j \endash  j * min_overlap < s}{\fs24\sub\insrsid10617789 j+1}{
\fs24\insrsid10617789  then the bound s}{\fs24\sub\insrsid10617789 j+1}{\fs24\insrsid10617789  + the sum of m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  over i = (j+1) to n \endash  (n-j-1) * min_overlap < max (f}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789 ) is a tighter bound. In fact these bounds are just a way of formalizing what the leftmost test is. We can use these bounds and a similar one \endash  if c}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  < c}{
\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  then s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  + m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  + m}{\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  \endash  min_overlap <= f}{
\fs24\sub\insrsid10617789 j}{\fs24\insrsid10617789  \endash  and the DAG to refine all of s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  and f}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  for each chunk c}{\fs24\sub\insrsid10617789 i}{
\fs24\insrsid10617789 . Conflicts would show up when s}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  + m}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789  > f}{\fs24\sub\insrsid10617789 i}{\fs24\insrsid10617789 
. Once the range coordinates are re
fined we may need to add new edges to the DAG to reflect pairs that used to be unordered but now can be ordered or we may even find pairs that used to be unordered but now conflict. We can then repeat doing the refinement and adding edges until we find a 
c
onflict or stabilize (note that we are guaranteed to stabilize in finite time since the ranges always are reduced and the number of edges which can be added to the DAG is finite). I cannot yet prove that if we stabilize without finding a conflict that the
re does exist an unbranched consistent path but I am starting to think this might be provable. If nothing else this algorithm seems worth pursuing just to be able to refine the range coordinates.
\par 
\par After some preliminary research the determination of a consi
stent path under the above formulation appears to be NP-hard/complete but I am not yet positive about the existence problem. What is also clear is that if a total or nearly total ordering can be determined then the problem is merely quadratic. I think a l
o
t of our actual problems will be highly ordered and hence solvable but one way to make this even more true is to increase the number of chunks which are partially ordered with respect to each other. The first thing we can do is check for the existence of 
m
ate edges between pairs of chunks not involving the initial chunk which are consistent with the range coordinates. If one of these mate edges exist it will immediately give a partial ordering of the pair of chunks and might refine the range coordinates fo
r the chunks as well. This approach is not without pitfalls because scenarios exist where the inference drawn may be incorrect due to one or both chunks being nonunique and the mate edge being consistent but not representative of the true path \endash 
 our current
 thinking is that these scenarios have low probability and the gain in ordering out weighs the risk. The next step could be to find all chunks in the chunk graph which connect any pair of our current set of chunks consistent with the range coordinates. Th
e
se very short paths in the chunk graph could be found very efficiently but we must remember they suffer the same pitfalls (not clear whether the risk is higher or lower than mate edges between pairs of chunks). Either of these can be extended to include l
onger path searches in the extended chunk graph to try to determine a partial order between pairs of chunks but the efficiency of the search will decrease and the risk might increase.
\par 
\par At this point I would plan to proceed with the two additional ordering steps given above and then construct the DAG for the partial order and iterate twice to refine the DAG as discussed above. If we have a total order with no conflicts we\rquote 
re done. If we have a conflict we\rquote re done. Otherwise we can use a simple heuristic to try to find an order that satisfies the DAG and the constraints and if we do we\rquote 
re done. Otherwise I would either assume there are no conflicts or try to search the extended chunk graph to get a better ordering. We can also choose to allow the extra ordering steps to confirm unconfirmed chunks.
\par 
\par We can extend each chunk as described above into what we will call a chunk\rquote s confirmed scaffold (note this is only for unique chunks) composed of a partial ordering of neighboring chunks and implied fuzzy coordinates 
with respect to the initiating chunk. At this point we could pursue a greedy approach by either extending scaffolds from the most unique remaining unextended chunk in the scaffold or by merging scaffolds based on a similar criterion. A more elegant and pe
r
haps insightful approach is to treat the scaffolds as elements which can be overlapped based on their unique chunk content. Once we do the overlapping we can produce an overlap graph and collapse this into a chunk graph for the scaffolds. If our uniquenes
s
 labeling is correct and discounting structural polymorphisms and chimeric confirmed mate edges there should be no branches in this chunk graph. The presence of branches would alert us to regions where we need to look for problems in our assumptions or th
e data.
\par 
\par The first challenge is to define what an overlap is between scaffolds. A minimum requirement is that the two scaffolds have at least one unique chunk in common and this condition should make the search for potential overlaps efficient. The second r
equirement is that the chunks the two scaffolds share have the same relative orientation and ordering in both scaffolds. These two requirements may be sufficient but at least two others should be considered: that the relative distances between shared chun
k
s be approximately the same and that merging the two scaffolds does not result in any obvious conflicts as defined previously. In any case, the two scaffolds should be merged and links between unshared chunks in the two scaffolds should be used to help re
f
ine any ambiguities in the partial orders of the two scaffolds and confirm any unconfirmed mate edges. There are two possibilities for characterizing the implied overlap of the merged scaffolds: the length of the overlap and overhangs can be estimated fro
m
 the fuzzy coordinates which will also imply the type of the overlap (contained, normal/prefix/suffix dovetail), or just the implied partial order of the merged scaffolds can be used to determine just the type of the overlap. Due to the nature of scaffold
s
 and unique chunks being used to determine overlaps we do not expect that there can be multiple legitimate overlaps between the same pair of scaffolds and will not allow these to occur. Under this assumption the type of an overlap alone is sufficient to p
e
rform transitive edge removal. One concern however is that the gaps inherent in the scaffolds if large enough to contain another scaffold or part of a scaffold can lead to branches in the collapsed graph which only exist because real overlaps between scaf
folds are not detected due to these gaps.
\par 
\par 
\par }\pard\plain \s1\ql \li0\ri0\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid10617789 Statistics and Testing
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs24\insrsid10617789 
\par This section delineates statistics that can be collected and tests that can be made especially for simulated data that can be used to assess the potential success of walker strategies and t
he correctness of clone mate information and walker algorithms. The statistics will mostly involve clone mates/mate edges since that is the primary basis of the walker algorithms. There are some obvious statistics to provide histograms for on a per chunk 
e
dge basis and possibly a per chunk basis which can be computed for the enhanced chunk graph before walking commences: internally consistent chunks, confirmed mate edges, unconfirmed mate edges, all mate edges, sum of chunk sizes for confirmed/unconfirmed/
a
ll mate edges, maximum extension off of the edge of a chunk via confirmed/unconfirmed/all mate edges, and ratio of extension filled (sum of chunk sizes divided by maximum extension) for confirmed/all chunk edges. These statistics would be grouped into sev
e
ral classes such as true unique chunks, true repeat chunks, chunks within a certain band of the uniqueness score, chunks within a certain size band, and/or some combination of these attributes. Some clone mate statistics we can collect are whether there a
r
e any confirmed mate edges which are the result of two or more chimeric clone mate pairs, there are any chimeric clone mate pairs which participate in legitimate mate edges, and the number of unconfirmed mate edges which are real versus chimeric. We can a
lso do some quick correctness checks based on the enhanced chunk graph such as whether the distance bounds on confirmed/unconfirmed/all mate edges are accurate.
\par 
\par We can make the above statistics more accurate and gather some additional statistics for
\par unique chunks which we can extend as described above based on the partial ordering and fuzzy coordinates which result. 
\par 
\par 
\par }\pard\plain \s1\ql \li0\ri0\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid10617789 Limitations
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs24\insrsid10617789 
\par Currently, the chunk graph walker will rely only on overlap edges and mate edges to traverse the chunk graph. In the future microhetergeneity within repeat chunks could also be used when other information is insufficient.
\par 
\par 
\par }{\b\fs24\insrsid10617789 Status
\par }{\fs24\insrsid10617789 
\par Design phase.
\par 
\par 
\par }{\b\fs24\insrsid10617789 Component Architecture and Unit Dependencies
\par }{\fs24\insrsid10617789 
\par from correctly labeled unique chunks. 
\par 
\par }{\b\fs24\insrsid10617789 
\par }\pard\plain \s18\ql \li0\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin0\itap0 \b\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid10617789 AUTHORS
\par }\pard\plain \s17\qj \li360\ri0\sb120\widctlpar\faauto\adjustright\rin0\lin360\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid10617789 Granger Sutton}{\f36\insrsid10617789 
\par Created: December 23, \rquote 98
\par Last revised: January 22, \lquote 99}{\insrsid10617789 
\par 
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\fs24\insrsid10617789 
\par }}