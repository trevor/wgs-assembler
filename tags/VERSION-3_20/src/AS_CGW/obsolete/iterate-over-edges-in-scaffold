
//  A nice example (for BPW anyway).  It came from CIScaffoldT_CGW.c,
//  CheckScaffoldConnectivityAndSplit(), attempting to fix the least
//  squares gap problem of getting a disconnected scaffold.

//  We're done creating newScaffoldID.  Get it again, iterate over all the CI's,
//  and mark edges to CI's not in this scaffold as inter-scaffold edges.
//
//  This turned out to be quite useless; the work is done 
{
  CIScaffoldTIterator  CIs;
  NodeCGW_T           *CI;
  GraphEdgeIterator    edges;
  EdgeCGW_T           *edge;

  InitCIScaffoldTIterator(graph, scaffold, TRUE, FALSE, &CIs);
  while((CI = NextCIScaffoldTIterator(&CIs)) != NULL) {

    InitGraphEdgeIterator(ScaffoldGraph->RezGraph, CI->id, 
                          ALL_END,
                          ALL_INTERNAL_EDGES, GRAPH_EDGE_RAW_ONLY,
                          &edges);

    while ((edge = NextGraphEdgeIterator(&edges))!= NULL) {
      NodeCGW_T *CIa = GetGraphNode(ScaffoldGraph->RezGraph, edge->idA);
      NodeCGW_T *CIb = GetGraphNode(ScaffoldGraph->RezGraph, edge->idB);

      //  If this edge is now between two scaffolds, mark it
      //  as so.
      //
      if ((CIa->scaffoldID != newScaffoldID) || (CIb->scaffoldID != newScaffoldID)) {
        fprintf(stderr, " edge from CI "F_CID" to "F_CID" reset to non-internal.\n",
                edge->idA, edge->idB);

        //  The SetEdgeStatus() will propagate our status to
        //  attached raw edges (according to the comments
        //  there).  But it also blows away all other status.
        //  BPW hopes that an edge can have only one status.
        //

        //edge->flags.bits.edgeStatus &= ~ALL_INTERNAL_EDGES;
        //edge->flags.bits.edgeStatus |=  INTER_SCAFFOLD_EDGE_STATUS;

        SetEdgeStatus(graph->RezGraph, edge, INTER_SCAFFOLD_EDGE_STATUS);
      }
    }
  }
}
