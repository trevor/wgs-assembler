
#if 0
int *my_Unpack_Alignment_AS(OverlapMesg *align) {
  static int    UnpackBuffer[2*AS_READ_MAX_LEN+1];
  signed char  *calign;
  int           apos, bpos;

  apos   = align->ahg + 1;  /* ahg >= 0 for all overlaps */
  bpos   = 1;
  calign = align->delta;

  {
    int i, c;
    int *spt;

    spt = UnpackBuffer;
    for (i = 0; (c = calign[i]) != 0; i++)
      if (c == AS_LONG_DELTA_CODE) {
        apos += AS_LONGEST_DELTA;      /* Uninterrupted match of 126 bases */
        bpos += AS_LONGEST_DELTA;
      } else if (c == AS_POLY_DELTA_CODE) {
        c = calign[++i];  /* Multi-base gap */
        if (c < 0)
          while (c < 0) {
            c    += 1;
            bpos += 1;
            *spt++ = -apos;
          }
        else
          while (c > 0) {
            c    -= 1;
            apos += 1;
            *spt++ = -bpos;
          }
      } else {
        if (c < 0) {        /* Single gap */
          bpos -= c;
          apos -= (c+1);
          *spt++ = -apos;
        } else {
          bpos += (c-1);
          apos += c;
          *spt++ = bpos;
        }
      }
    *spt = 0;
  }

  return (UnpackBuffer);
}
#endif







#if 0
void extendUnitigs(NodeCGW_T *unitig, int fragIid, extendableFrag extFrag, int leftContig)
{
  // have to alter the following fields in a NodeCGW_T: bpLength, offsetAEnd, offsetBEnd
  int unitigLeftEnd, unitigRightEnd, unitigOrientation;
  int AEnd;
  
  // GetContigPositionInScaffold(contig, &contigLeftEnd, &contigRightEnd, &contigOrientation);
  GetChunkPositionInContig(unitig, &unitigLeftEnd, &unitigRightEnd, &unitigOrientation);

  unitig->bpLength.mean += extFrag.extension;
  
  // the unitig we're extending has to be on one end or the other of the contig
  if (unitigLeftEnd == 0 || unitigRightEnd == 0)
    AEnd = TRUE;
  else
    AEnd = FALSE;

  if (AEnd == TRUE)
    {
      ContigTIterator contigIter;
      NodeCGW_T *currUnitig;
      ContigT *contig = GetGraphNode(ScaffoldGraph->ContigGraph, unitig->info.CI.contigID);
	
      InitContigTIterator(ScaffoldGraph, contig->id, TRUE, FALSE, &contigIter);
      while (NextContigTIterator(&contigIter))
	{
	  currUnitig = GetGraphNode(ScaffoldGraph->CIGraph, contigIter.curr);

	  if (currUnitig->id != unitig->id)  // adjust everybody upwards except extended unitig
            {
              currUnitig->offsetAEnd.mean += extFrag.extension;
              currUnitig->offsetBEnd.mean += extFrag.extension;
            }
	  else
            {
              if (unitigOrientation == 0 /* A_B */)
                currUnitig->offsetBEnd.mean += extFrag.extension;
              else  // unitig is B_A in contig
                unitig->offsetAEnd.mean += extFrag.extension;
            }
	}
    }
  else
    {
      if (unitigOrientation == 0 /* A_B */)
	{
	  fprintf (stderr, "extending AEnd of unitig %8d from %.0f to %.0f\n",
                   unitig->id, unitig->offsetAEnd.mean, unitig->offsetAEnd.mean + extFrag.extension);
	  unitig->offsetBEnd.mean += extFrag.extension;
	}
      else // unitigOrientation == 1 /* B_A */
	{
	  fprintf (stderr, "extending AEnd of unitig %8d from %.0f to %.0f\n",
                   unitig->id, unitig->offsetAEnd.mean, unitig->offsetAEnd.mean + extFrag.extension);
	  unitig->offsetAEnd.mean += extFrag.extension;
	}
    }
}
#endif







#if 0
int printClearRanges(int fragIid)
{
  unsigned int clr_bgn, clr_end;
  int setStatus = 0;
  
  if(fsread == NULL) fsread = new_ReadStruct();

  if (fragIid != -1)
    {
      FragStoreHandle fragStore;

      fragStore = openFragStore(GlobalData->Frag_Store_Name, "r");
      getFragStore(fragStore, fragIid, FRAG_S_ALL, fsread);	

      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_ORIGINAL);
      fprintf(stderr, "printClearRanges, frag %8d READSTRUCT_ORG clr_bgn: %5d, clr_end %5d, len: %4d\n",
              fragIid, clr_bgn, clr_end, clr_end - clr_bgn);

      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_OVL);
      fprintf(stderr, "printClearRanges, frag %8d READSTRUCT_OVL clr_bgn: %5d, clr_end %5d, len: %4d\n",
              fragIid, clr_bgn, clr_end, clr_end - clr_bgn);

      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);
      fprintf(stderr, "printClearRanges, frag %8d READSTRUCT_CNS clr_bgn: %5d, clr_end %5d, len: %4d\n",
              fragIid, clr_bgn, clr_end, clr_end - clr_bgn);

      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CGW);
      fprintf(stderr, "printClearRanges, frag %8d READSTRUCT_CGW clr_bgn: %5d, clr_end %5d, len: %4d\n",
              fragIid, clr_bgn, clr_end, clr_end - clr_bgn);

      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_LATEST);
      fprintf(stderr, "printClearRanges, frag %8d READSTRUCT_LAT clr_bgn: %5d, clr_end %5d, len: %4d\n",
              fragIid, clr_bgn, clr_end, clr_end - clr_bgn);

      closeFragStore(fragStore);
    }

  return (setStatus); 
}
#endif




int compIMPs(const void *s1, const void *s2)
{
  const IntMultiPos * t1 = s1;
  const IntMultiPos * t2 = s2;
  assert(t1 == s1);
  assert(t2 == s2);
  
  if (min(t1->position.bgn, t1->position.end) < min(t2->position.bgn, t2->position.end))
    return -1;
  else if (min(t1->position.bgn, t1->position.end) > min(t2->position.bgn, t2->position.end))
    return 1;
  else {
    if (t1 > t2)
      return -1;
    else if (t2 < t1)
      return 1;
    else  // should never happen
      return 0;
  }
}





// findFirstFrag looks for a 3p->5p frag at the low end of a contig
// basesToNextFrag has meaning only when the first frag is the end frag, since basesToNextFrag
// marks where we start to have 2x coverage and is then used to determine MaxBegGap or MaxEndGap
int findFirstFrag(ContigT *contig, int *fragIid, int *extensionOut, int *basesToNextFrag)
{
  MultiAlignT *ma;
  IntMultiPos *mp;
  CIFragT *frag;
  int i, numFrags;
  int foundFrag, fragOnEnd = FALSE;
  int currExtension = 0, secondFragStart = 10000;
  
  fprintf(stderr, "in FindFirstFrag\n");
  
  ma = LoadMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE); 
  numFrags = GetNumIntMultiPoss(ma->f_list);

  // fprintf(stderr, "contig %d has %d frags over a length of %f\n", contig->id, numFrags, contig->bpLength.mean);
  // fprintf(stderr, "contig %d has %d unitigs over a length of %f\n", contig->id, 
  //   GetNumIntUnitigPoss(ma->u_list), contig->bpLength.mean);
  
  foundFrag = FALSE;
  *extensionOut = 0;
  for (i = 0; i < numFrags; i++) {
    mp = GetIntMultiPos(ma->f_list, i);
    frag = GetCIFragT(ScaffoldGraph->CIFrags, (int32) mp->source);

    if (frag->contigOffset3p.mean < 100.0 &&      // frag is within a cutoff of the low end of the contig
        frag->locale == -1 &&                     // and is a read
        frag->contigOffset3p.mean < frag->contigOffset5p.mean) {
      // and points in the right direction
      char seqbuffer[AS_BACTIG_MAX_LEN+1], qltbuffer[AS_BACTIG_MAX_LEN+1];
      unsigned int clr_bgn, clr_end;
      int frag3pExtra, extension;
	  
      getFragStore(ScaffoldGraph->fragStore, frag->iid, FRAG_S_ALL, fsread);
      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);
      getSequence_ReadStruct(fsread, seqbuffer, qltbuffer, AS_BACTIG_MAX_LEN);


      //                 <--------------------------------------------------------------------------- contig
      // 3p <------------------|---------------------------------------------|----- 5p frag
      //                    clr_end                                       clr_bgn
      //    |-----------|
      //      extension

      //             <--------------------------------------------------------------------------- contig
      //                     <-|---------------------------------------------|----- 5p frag
      //                    clr_end                                       clr_bgn
      //             |------|
      //               extension (negative)

      fprintf(stderr, "contig->bpLength.mean: %f\n", contig->bpLength.mean);
      fprintf(stderr, "frag iid: %d, frag->contigOffset5p.mean: %f, frag->contigOffset3p.mean: %f\n",
              frag->iid, frag->contigOffset5p.mean, frag->contigOffset3p.mean);
      fprintf(stderr, "frag length: " F_SIZE_T ", 3p past clr_end length: " F_SIZE_T "\n", strlen(seqbuffer), 
              strlen(seqbuffer) - clr_end);
      fprintf(stderr, "extension: " F_SIZE_T "\n", strlen(seqbuffer) - clr_end - (int) frag->contigOffset3p.mean);
	  
      frag3pExtra = strlen(seqbuffer) - clr_end;
      extension = frag3pExtra - frag->contigOffset3p.mean;

      if (extension > currExtension) {
        currExtension = strlen(seqbuffer) - clr_end - frag->contigOffset3p.mean;
        foundFrag = TRUE;
        if (frag->contigOffset3p.mean == 0)
          fragOnEnd = TRUE;
        else
          fragOnEnd = FALSE;
        *extensionOut = currExtension;
        *fragIid = frag->iid;

#ifdef DEBUG_ECR
        fprintf(stderr, "in contig %d, frag %d is at %f -> %f (5p->3p) \n", 
                contig->id, frag->iid,
                frag->contigOffset5p.mean, frag->contigOffset3p.mean);
        fprintf(stderr, "extension ratio: %.2f\n", extension / (float) (1.0 + frag3pExtra - extension));
#endif
      }
    }

    // secondFragStart is where the next to end frag starts, and thus where we start 2x coverage
    // we don't care if it's the 3p or 5p end
    if (frag->contigOffset3p.mean > 0 && (int) frag->contigOffset3p.mean < secondFragStart)
      {
        secondFragStart = frag->contigOffset3p.mean;
        // fprintf(stderr, "secondFragStart %d set by frag %d (3p)\n", secondFragStart, frag->iid);
      }
    if ((int) frag->contigOffset5p.mean < secondFragStart)
      {
        secondFragStart = frag->contigOffset5p.mean;
        // fprintf(stderr, "secondFragStart %d set by frag %d (5p)\n", secondFragStart, frag->iid);
      }
  }

  if (fragOnEnd == TRUE)
    *basesToNextFrag = secondFragStart;
  else
    *basesToNextFrag = 0;

  // fprintf(stderr, "basesToNextFrag: %d\n", *basesToNextFrag);
  
  return foundFrag;
}





// findLastFrag looks for a 5p->3p frag at the high end of a contig
// basesToNextFrag has meaning only when the first frag is the end frag, since basesToNextFrag
// marks where we start to have 2x coverage and is then used to determine MaxBegGap or MaxEndGap
int findLastFrag(ContigT *contig, int *fragIid, int *extensionOut, int *basesToNextFrag)
{
  MultiAlignT *ma;
  IntMultiPos *mp;
  CIFragT *frag;
  int i, numFrags;
  int foundFrag = FALSE, fragOnEnd = FALSE;
  float maxContigPos;
  int currExtension = 0, secondFragEnd = 0;

  fprintf(stderr, "in FindLastFrag\n");
  
  ma = LoadMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE); 
  numFrags = GetNumIntMultiPoss(ma->f_list);
  
  maxContigPos = contig->bpLength.mean - 1.0;
  
  *extensionOut = 0;
  for (i = 0; i < numFrags; i++) {
    mp = GetIntMultiPos(ma->f_list, i);
    frag = GetCIFragT(ScaffoldGraph->CIFrags, (int32) mp->source);

    // if (frag->contigOffset3p.mean == maxContigPos && frag->locale == -1)
    if (frag->contigOffset3p.mean > maxContigPos - 100.0 &&      // frag is within a cutoff of the high end of the contig
        frag->locale == -1 &&                                    // and is a read
        frag->contigOffset5p.mean < frag->contigOffset3p.mean)   // and points in the right direction
      {
        char seqbuffer[AS_BACTIG_MAX_LEN+1], qltbuffer[AS_BACTIG_MAX_LEN+1];
        unsigned int clr_bgn, clr_end;
        int frag3pExtra, extension;

        getFragStore(ScaffoldGraph->fragStore, frag->iid, FRAG_S_ALL, fsread);
        getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);
        getSequence_ReadStruct(fsread, seqbuffer, qltbuffer, AS_BACTIG_MAX_LEN);

        //    contig ----------------------------------------------------------------------------------->
        //                                  5p -------|---------------------------------------------|------------> 3p 
        //                                         clr_bgn                                       clr_end
        //                                                                                               |-------|
        //                                                                                             extension
        frag3pExtra = strlen(seqbuffer) - clr_end;
        extension = frag3pExtra - (int) (contig->bpLength.mean - frag->contigOffset3p.mean);

        fprintf(stderr, "contig->bpLength.mean: %f\n", contig->bpLength.mean);
        fprintf(stderr, "frag iid: %d, frag->contigOffset5p.mean: %f, frag->contigOffset3p.mean: %f\n",
                frag->iid, frag->contigOffset5p.mean, frag->contigOffset3p.mean);
        fprintf(stderr, "frag length: " F_SIZE_T ", 3p past clr_end length: %d\n", strlen(seqbuffer), frag3pExtra);
        fprintf(stderr, "extension: %d\n", extension);
	  
        if (extension > currExtension) {
          currExtension = extension;
          foundFrag = TRUE;
          if (frag->contigOffset3p.mean == contig->bpLength.mean)
            fragOnEnd = TRUE;
          else
            fragOnEnd = FALSE;
          *extensionOut = currExtension;
          *fragIid = frag->iid;

#ifdef DEBUG_ECR
              fprintf(stderr, "in contig %d, frag %d is at %f -> %f (5p->3p) maxContigPos: %f\n", 
                      contig->id, frag->iid,
                      frag->contigOffset5p.mean, frag->contigOffset3p.mean, maxContigPos);
              fprintf(stderr, "extension ratio: %.2f\n", extension / (float) (1.0 + frag3pExtra - extension));
#endif
        }
      }

    // secondFragEnd is where the next to end frag ends, and thus where we have 2x coverage
    // we don't care if it's the 3p or 5p end
    if (frag->contigOffset3p.mean < contig->bpLength.mean && (int) frag->contigOffset3p.mean > secondFragEnd)
      {
        secondFragEnd = (int) frag->contigOffset3p.mean;
        // fprintf(stderr, "secondFragEnd %d set by frag %d (3p)\n", secondFragEnd, frag->iid);
      }
    if ((int) frag->contigOffset5p.mean > secondFragEnd)
      {
        secondFragEnd = frag->contigOffset5p.mean;
        // fprintf(stderr, "secondFragEnd %d set by frag %d (5p)\n", secondFragEnd, frag->iid);
      }
  }
  if (fragOnEnd == TRUE)
    *basesToNextFrag = (int) contig->bpLength.mean - secondFragEnd;
  else
    *basesToNextFrag = 0;
  // fprintf(stderr, "basesToNextFrag: %d\n", *basesToNextFrag);

  return foundFrag;
}



void produceContigStatsConventional()
{
  double totalLengthContigs = 0.0;
  int numContigs = 0;
  int sid;
  
  for (sid = 0; sid < GetNumGraphNodes(ScaffoldGraph->ScaffoldGraph); sid++) {
    CIScaffoldTIterator CIsTemp;
    CIScaffoldT * scaff;
    int icnt;
    // int leftFragFound, rightFragFound;
	
    scaff = GetGraphNode(ScaffoldGraph->ScaffoldGraph, sid);
    // make sure the scaffold is there
    assert(scaff != NULL);
    
    // not interested in dead scaffold, not real scaffolds, or singleton scaffolds
    
    if ((isDeadCIScaffoldT(scaff)) ||
        (scaff->type != REAL_SCAFFOLD)) // || (scaff->info.Scaffold.numElements < 2))
      {
        continue;
      }
    fprintf(stderr,"\n=====================================================================\n");
    fprintf(stderr,"=== examing scaffold %d, size %f\n", sid, scaff->bpLength.mean);

    // make sure the scaffold is there
    assert(scaff != NULL);

    icnt = 0;
    InitCIScaffoldTIterator(ScaffoldGraph, scaff, TRUE,	FALSE, &CIsTemp);
    while (NextCIScaffoldTIterator(&CIsTemp))
      {
        ContigT *contig;
	  
        contig = GetGraphNode(ScaffoldGraph->RezGraph, CIsTemp.curr);
        assert(contig != NULL);

        totalLengthContigs += contig->bpLength.mean;
        numContigs++;

        // if at end of scaffold break
        if (CIsTemp.next == -1)
          break;
      }
  }
  fprintf(stderr, "produceContigStatsConventional, numContigs: %d, avg contig length: %f\n", 
          numContigs, totalLengthContigs / numContigs);
}

void produceGapStats(int numGaps, int *closedGap, int *closedGapDelta, int *originalGaps)
{
  int i;
  FILE *alteredGapsFile;
  FILE *originalGapsFile;
  
  originalGapsFile = fopen("originalGaps.cgm", "w");
  if (originalGapsFile == NULL) {
    fprintf(stderr, "failed to open originalGapsFile\n");
    assert(0);
  }
  fprintf(originalGapsFile, "original gaps\n");

  for (i = 0; i < numGaps; i++)
    fprintf(originalGapsFile, "%d\n", originalGaps[i]);

  fclose(originalGapsFile);

  alteredGapsFile = fopen("alteredGaps.cgm", "w");
  if (alteredGapsFile == NULL) {
    fprintf(stderr, "failed to open alteredGapsFile\n");
    assert(0);
  }
  fprintf(alteredGapsFile, "altered gaps\n");

  for (i = 0; i < numGaps; i++) {
    if (closedGap[i] == FALSE)
      fprintf(alteredGapsFile, "%d\n", originalGaps[i]);
  }
  
  fclose(originalGapsFile);
}

void produceScaffoldStats(int *alteredScaffoldLengths)
{
  int sid;
  FILE *alteredScaffoldsFile;
  FILE *originalScaffoldsFile;
  
  originalScaffoldsFile = fopen("originalScaffolds.cgm", "w");
  if (originalScaffoldsFile == NULL) {
    fprintf(stderr, "failed to open originalScaffoldsFile\n");
    assert(0);
  }
  fprintf(originalScaffoldsFile, "original scaffolds\n");

  alteredScaffoldsFile = fopen("alteredScaffolds.cgm", "w");
  if (alteredScaffoldsFile == NULL) {
    fprintf(stderr, "failed to open alteredScaffoldsFile\n");
    assert(0);
  }
  fprintf(alteredScaffoldsFile, "altered scaffolds\n");

  for (sid = 0; sid < GetNumGraphNodes(ScaffoldGraph->ScaffoldGraph); sid++) {
    CIScaffoldT * scaff;
    // int leftFragFound, rightFragFound;
	
    scaff = GetGraphNode(ScaffoldGraph->ScaffoldGraph, sid);
    // make sure the scaffold is there
    assert(scaff != NULL);
    
    // not interested in dead scaffold, not real scaffolds, or singleton scaffolds
    
    if ((isDeadCIScaffoldT(scaff)) || (scaff->type != REAL_SCAFFOLD) 
        || (scaff->info.Scaffold.numElements < 2))
      {
        continue;
      }
	
    // make sure the scaffold is there
    assert(scaff != NULL);
	
    fprintf(originalScaffoldsFile, "%d\n", (int) scaff->bpLength.mean);
    // at this point alteredScaffoldLengths has only the deltas for its gaps, not the deltas plus the original length 
    fprintf(alteredScaffoldsFile, "%d\n", alteredScaffoldLengths[sid]);
  }
  
  fclose(originalScaffoldsFile);
  fclose(alteredScaffoldsFile);
}

void produceContigStats(int numGaps, int *closedGap, int *closedGapDelta,
                        int *lcontigIdGap, int *rcontigIdGap, int *lcontigLength, int *rcontigLength,
                        int *contigValid, int *allContigLengths, int numDeletedContigs) {
  double totalLengthContigs = 0.0;
  int numContigs = 0;
  int sid;
  FILE *alteredContigsFile;
  
  alteredContigsFile = fopen("alteredContigs.cgm", "w");
  if (alteredContigsFile == NULL) {
    fprintf(stderr, "failed to open alteredContigsFile\n");
    assert(0);
  }
  fprintf(alteredContigsFile, "altered contigs\n");

  for (sid = 0; sid < GetNumGraphNodes(ScaffoldGraph->ScaffoldGraph); sid++) {
    CIScaffoldTIterator CIsTemp;
    CIScaffoldT * scaff;
    int icnt;
    // int leftFragFound, rightFragFound;
	
    scaff = GetGraphNode(ScaffoldGraph->ScaffoldGraph, sid);
    // make sure the scaffold is there
    assert(scaff != NULL);
    
    // not interested in dead scaffold, not real scaffolds, or singleton scaffolds
    
    if ((isDeadCIScaffoldT(scaff)) ||
        (scaff->type != REAL_SCAFFOLD)) // || (scaff->info.Scaffold.numElements < 2))
      {
        continue;
      }
    fprintf(stderr,"\n=====================================================================\n");
    fprintf(stderr,"=== examing scaffold %d, size %f\n", sid, scaff->bpLength.mean);

    // make sure the scaffold is there
    assert(scaff != NULL);

    icnt = 0;
    InitCIScaffoldTIterator(ScaffoldGraph, scaff, TRUE,	FALSE, &CIsTemp);
    while (NextCIScaffoldTIterator(&CIsTemp))
      {
        ContigT *contig;
	  
        contig = GetGraphNode(ScaffoldGraph->RezGraph, CIsTemp.curr);
        assert(contig != NULL);

        // totalLengthContigs += contig->bpLength.mean;
        if (contigValid[ contig->id ]) {
          totalLengthContigs += allContigLengths[ contig->id ];
          numContigs++;
          fprintf(alteredContigsFile, "%d\n", allContigLengths[ contig->id ]);
        }
	  
        // if at end of scaffold break
        if (CIsTemp.next == -1)
          break;
      }
  }
  fclose(alteredContigsFile);
  fprintf(stderr, "produceContigStats, numContigs: %d, avg contig length: %f\n", 
          numContigs, totalLengthContigs / numContigs);
}



void collectContigStats(int *allContigLengths, int *contigValid)
{
  double totalLengthContigs = 0.0;
  int numContigs = 0;
  int sid;
  
  for (sid = 0; sid < GetNumGraphNodes(ScaffoldGraph->ScaffoldGraph); sid++) {
    CIScaffoldTIterator CIsTemp;
    CIScaffoldT * scaff;
    int icnt;
    // int leftFragFound, rightFragFound;
	
    scaff = GetGraphNode(ScaffoldGraph->ScaffoldGraph, sid);
    // make sure the scaffold is there
    assert(scaff != NULL);
    
    // not interested in dead scaffold, not real scaffolds, or singleton scaffolds
    
    if ((isDeadCIScaffoldT(scaff)) ||
        (scaff->type != REAL_SCAFFOLD)) // || (scaff->info.Scaffold.numElements < 2))
      {
        continue;
      }
    fprintf(stderr,"\n=====================================================================\n");
    fprintf(stderr,"=== examing scaffold %d, size %f\n", sid, scaff->bpLength.mean);

    // make sure the scaffold is there
    assert(scaff != NULL);

    icnt = 0;
    InitCIScaffoldTIterator(ScaffoldGraph, scaff, TRUE,	FALSE, &CIsTemp);
    while (NextCIScaffoldTIterator(&CIsTemp))
      {
        ContigT *contig;
	  
        contig = GetGraphNode(ScaffoldGraph->RezGraph, CIsTemp.curr);
        assert(contig != NULL);

        contigValid[ contig->id ] = TRUE;
        allContigLengths[ contig->id ] = (int) contig->bpLength.mean;

        totalLengthContigs += contig->bpLength.mean;
        numContigs++;

        // if at end of scaffold break
        if (CIsTemp.next == -1)
          break;
      }
  }
  fprintf(stderr, "collectContigStats, numContigs: %d, avg contig length: %f\n", 
          numContigs, totalLengthContigs / numContigs);
}



void printGapSizes()
{
  int sid;
  
  for (sid = 0; sid < GetNumGraphNodes(ScaffoldGraph->ScaffoldGraph); sid++)
    {
      CIScaffoldTIterator CIsTemp;
      CIScaffoldT * scaff;
      int icnt;
      LengthT gapEstimate;
	
      scaff = GetGraphNode(ScaffoldGraph->ScaffoldGraph, sid);
      // make sure the scaffold is there
      assert(scaff != NULL);
    
      // not interested in dead scaffold, not real scaffolds, or singleton scaffolds    
      if ((isDeadCIScaffoldT(scaff)) ||
          (scaff->type != REAL_SCAFFOLD) ||
          (scaff->info.Scaffold.numElements < 2))
	{
	  continue;
	}
      fprintf(stderr,"\n=====================================================================\n");
      fprintf(stderr,"=== examining scaffold %d, size %f\n", sid, scaff->bpLength.mean);
	  
      icnt = 0;
      InitCIScaffoldTIterator(ScaffoldGraph, scaff, TRUE,
                              FALSE, &CIsTemp);
      while (NextCIScaffoldTIterator(&CIsTemp))
	{
	  ChunkInstanceT *lchunk, *rchunk;

	  // not walking off of scaffolds currently
	  if (CIsTemp.next == -1)
            break;
	  
          // find the chunks in the gap by walking between the chunk <CIs.curr>
          // and the chunk <CIs.next>
          lchunk = GetGraphNode(ScaffoldGraph->RezGraph, CIsTemp.curr);
          assert(lchunk != NULL);

	  rchunk = GetGraphNode(ScaffoldGraph->RezGraph, CIsTemp.next);
          assert(rchunk != NULL);

	  gapEstimate = FindGapLength(lchunk, rchunk, TRUE);

	  fprintf(stderr, "gap between contigs %8d and %8d is %8.0f\n",
                  lchunk->id, rchunk->id, gapEstimate.mean);
	}
    }
}




int dumpFragInfo(int fragIid)
{
  CIFragT *frag;
  InfoByIID *info;    

  info = GetInfoByIID(ScaffoldGraph->iidToFragIndex, fragIid);
  assert(info->set);
  frag = GetCIFragT(ScaffoldGraph->CIFrags, info->fragIndex);
  
  fprintf(stderr, "    frag: %6d\t contig id: %d\t contig pos (5p, 3p): %6d, %6d\n", 
          fragIid, frag->contigID, (int) frag->contigOffset5p.mean, (int) frag->contigOffset3p.mean);	  
  
  return 0;
}




// are things in the frag store always stored 5p -> 3p?
int setCgwClearRange(int fragIid, int frag3pDelta)
{
  unsigned int clr_bgn, clr_end;
  int setStatus = 0;
  
  if (fragIid != -1) {
      getFragStore(ScaffoldGraph->fragStore, fragIid, FRAG_S_ALL, fsread);	
      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);
      setClearRegion_ReadStruct(fsread, clr_bgn, clr_end + frag3pDelta, READSTRUCT_CGW);
	
      setStatus = setFragStore(ScaffoldGraph->fragStore, fragIid, fsread);

      fprintf(stderr, "setCgwClearRange, changed frag %d clr_end from %d to %d\n",
              fragIid, clr_end, clr_end + frag3pDelta);
    }
  return (setStatus); 
}

int setCgwClearRangeAbs(int fragIid, int new_clr_bgn, int new_clr_end)
{
  unsigned int clr_bgn, clr_end;
  int offset, setStatus = 0;
  
  if (fragIid != -1) {
      getFragStore(ScaffoldGraph->fragStore, fragIid, FRAG_S_ALL, fsread);
      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);

      fprintf(stderr, "as read, frag %d clr_bgn %d, clr_end %d\n",
              fragIid, clr_bgn, clr_end);

      setClearRegion_ReadStruct(fsread, new_clr_bgn, new_clr_end, READSTRUCT_CGW);
	
      {
        FILE *srcStore = fopen("chr21_newer.frgStore/db.frg", "r+");
	  
        if (srcStore == NULL)
	  {
            fprintf(stderr, "failed to open srcStore\n");
            exit(1);
	  }
        offset = fragIid * 56 - 8;
        fprintf(stderr, "offset: %d\n", offset);
        CDS_FSEEK(srcStore, (off_t) offset, SEEK_SET);  // offset should be 17038664 for frag 304262
	  
        safeWrite(srcStore, fsread, 56);  
        fclose(srcStore);
      }
      getFragStore(ScaffoldGraph->fragStore, fragIid, FRAG_S_ALL, fsread);	
      getClearRegion_ReadStruct(fsread, &clr_bgn, &clr_end, READSTRUCT_CNS);

      fprintf(stderr, "set frag %d clr_bgn to %d, clr_end to %d\n",
              fragIid, new_clr_bgn, new_clr_end);
    }

  return (setStatus); 
}




// this transfers the updated values from the nodes in the CIGraph to the containing contig
void updateIntUnitigPoss(NodeCGW_T *contig)
{
  int i, numUnitigs;
  MultiAlignT *cma = LoadMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE);
  MultiAlignT *new_cma = NULL;
  
  numUnitigs = GetNumIntUnitigPoss(cma->u_list);

  if (UnitigPositions == NULL)
    UnitigPositions = CreateVA_IntElementPos(numUnitigs);
  ResetVA_IntElementPos(UnitigPositions);

  for (i = 0; i < numUnitigs; i++)
    {
      IntUnitigPos *upos = GetIntUnitigPos(cma->u_list, i);
      NodeCGW_T *unitig = GetGraphNode(ScaffoldGraph->CIGraph, upos->ident);
      IntElementPos unitigPos;

      fprintf(stderr, "changing unitig %8d pos from (%10d, %10d) to (%10d, %10d)\n",
              unitig->id, upos->position.bgn, upos->position.end, 
              (int) unitig->offsetAEnd.mean, (int) unitig->offsetBEnd.mean);
      upos->position.bgn = unitig->offsetAEnd.mean;
      upos->position.end = unitig->offsetBEnd.mean;

      // load up UnitigPositions
      unitigPos.ident = unitig->id;
      unitigPos.type = AS_UNITIG;
      unitigPos.position.bgn = unitig->offsetAEnd.mean;
      unitigPos.position.end = unitig->offsetBEnd.mean;
      AppendIntElementPos(UnitigPositions, &unitigPos);
    }

  // ReLoadMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, new_cma, contig->id, FALSE);

  new_cma = MergeMultiAlignsFast_new(ScaffoldGraph->sequenceDB,
                                     ScaffoldGraph->fragStore,
                                     UnitigPositions, FALSE, TRUE, GlobalData->aligner, NULL);

  // RemoveMultiAlignFromStore(ScaffoldGraph->sequenceDB, contig->id);
  // DeleteMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE);
  UnloadMultiAlignTFromSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE);
  InsertMultiAlignTInSequenceDB(ScaffoldGraph->sequenceDB, contig->id, FALSE, new_cma, TRUE);
}



// this is fast, things are mostly in order
void bubbleSortIUMs(IntMultiPos *f_list, int numIMPs)
{
  IntMultiPos tempIMP;
  int i, j;
  
  for (i = numIMPs; --i > 0;)
    {
      for (j = 0; j < i; j++)
	{	  
	  if (min(f_list[j].position.bgn, f_list[j].position.end) > 
              min(f_list[j+1].position.bgn, f_list[j+1].position.end))
            {
              if (f_list[0].ident == 300268)
                fprintf(stderr, "swapping %2d (frag %8d) and %2d (frag %8d)\n", i, f_list[i].ident, j, f_list[j].ident);

              memcpy(&tempIMP, &f_list[j], sizeof(IntMultiPos));
              memcpy(&f_list[j], &f_list[j+1], sizeof(IntMultiPos));
              memcpy(&f_list[j+1], &tempIMP, sizeof(IntMultiPos));
            }
	}
    }
}


