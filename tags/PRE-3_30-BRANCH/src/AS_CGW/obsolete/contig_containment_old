
#define DOIT

void   ContigContainment_old(CIScaffoldT *scaffold, NodeCGW_T *prevCI, NodeCGW_T *thisCI, EdgeCGW_T *overlapEdge){
  ContigT *containingContig;
  ContigT *containedContig;
  IntElementPos contigPos;
  int mergeStatus = 0;

  if(ContigPositions == NULL){
    ContigPositions = CreateVA_IntElementPos(10);
  }
  ResetVA_IntElementPos(ContigPositions);

  if(overlapEdge->flags.bits.aContainsB){
    fprintf(GlobalData->stderrc,"* ContigContainment A (" F_CID ") contains B (" F_CID ")  prevCI = " F_CID "  thisCI = " F_CID "\n",
			overlapEdge->idA, overlapEdge->idB, prevCI->id, thisCI->id);
    if(prevCI->id == overlapEdge->idA){
#ifdef DOIT
      containingContig = prevCI;
      containedContig = thisCI;
#endif
    }else{
      fprintf(GlobalData->stderrc,"*  prevCI is contained!!!!!\n");
#ifdef DOIT
      containedContig = prevCI;
      containingContig = thisCI;
#endif
    }
  }else if(overlapEdge->flags.bits.bContainsA){
    fprintf(GlobalData->stderrc,"* ContigContainment B (" F_CID ") contains A (" F_CID ")  prevCI = " F_CID "  thisCI = " F_CID "\n",
			overlapEdge->idB, overlapEdge->idA, prevCI->id, thisCI->id);
    if(prevCI->id == overlapEdge->idB){
#ifdef DOIT
      containingContig = prevCI;
      containedContig = thisCI;
#endif
    }else{
      fprintf(GlobalData->stderrc,"*  prevCI is contained!!!!!\n");
#ifdef DOIT
      containedContig = prevCI;
      containingContig = thisCI;
#endif
    }
  }else{
    assert(0);
  }
#ifndef DOIT
  // Given the way this is called by least squares, the left most contig should be the containing contig --- NOT!
  // If least squares things it is  dovetail, and it is a contain, the order can be reversed
  containedContig = thisCI;
  containingContig = prevCI;
#endif
  fprintf(GlobalData->stderrc,"* Containing contig is " F_CID " contained contig is " F_CID "\n",
	  containingContig->id, containedContig->id);

  /* Now the ContigEnds VA contains the starts/ends of all the contigs */
  {


    double aEndPos = 0., bEndPos = 0.;
    double overlap = -overlapEdge->distance.mean;
    // all calculations assume that the containing contig is in the same direction as the scaffold
    // flip corrects for the opposite case
    int flip = (containingContig->offsetBEnd.mean < containingContig->offsetAEnd.mean) ? -1 : 1;

    switch(GetEdgeOrientationWRT(overlapEdge,containingContig->id)){
	  case AB_AB:
		//              ----------------------->    NORMAL  AB_AB
		//                ---------------->
		//                |--------------------|   overlap
		aEndPos = containingContig->offsetBEnd.mean - flip * overlap;
		bEndPos = aEndPos + flip * containedContig->bpLength.mean;
		break;
	  case BA_BA:
		//               ------------------------>    Anti-NORMAL AB_BA
		//                 --------------->
		//               |----------------|           overlap
		bEndPos = containingContig->offsetAEnd.mean + flip * overlap;
		aEndPos = bEndPos - flip * containedContig->bpLength.mean;
		break;
	  case BA_AB:
		//               ----------------------->    Outie
		//                 <---------------
		//               |----------------|          overlap
		aEndPos = containingContig->offsetAEnd.mean +  flip * overlap;
		bEndPos = aEndPos - flip * containedContig->bpLength.mean;
		break;
	  case AB_BA:
		//              ----------------------->    Innie  AB_BA
		//               <----------------
		//               |---------------------|   overlap
		bEndPos = containingContig->offsetBEnd.mean - flip * overlap;
		aEndPos = bEndPos + flip * containedContig->bpLength.mean;
		break;
          default:
            assert(0);
            break;
    }
    contigPos.ident = containingContig->id;
    contigPos.type = AS_CONTIG;
    contigPos.position.bgn = containingContig->offsetAEnd.mean;
    contigPos.position.end = containingContig->offsetBEnd.mean;
    AppendIntElementPos(ContigPositions, &contigPos);
    contigPos.ident = containedContig->id;
    contigPos.type = AS_CONTIG;
	contigPos.position.bgn = aEndPos;
    contigPos.position.end = bEndPos;
	// contigPos.position.bgn = containingContig->offsetAEnd.mean;
	// contigPos.position.end = containingContig->offsetBEnd.mean;
    AppendIntElementPos(ContigPositions, &contigPos);
	
    fprintf(GlobalData->stderrc,"* Positions:\n\t" F_CID " [%g,%g]\n\t" F_CID " [%g,%g]\n",
			containingContig->id, containingContig->offsetAEnd.mean, containingContig->offsetBEnd.mean,
			containedContig->id, aEndPos, bEndPos);
	
    flip = (containingContig->offsetBEnd.mean < containingContig->offsetAEnd.mean);
    if(flip){
      mergeStatus = CreateAContigInScaffold(scaffold, ContigPositions, containingContig->offsetBEnd, containingContig->offsetAEnd);
    }else{
      mergeStatus = CreateAContigInScaffold(scaffold, ContigPositions, containingContig->offsetAEnd, containingContig->offsetBEnd);
	}
    assert(mergeStatus == TRUE);
  }
}
