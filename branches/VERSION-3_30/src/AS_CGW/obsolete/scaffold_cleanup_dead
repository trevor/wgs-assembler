

I came from the end of CIscaffold_Cleanup_CGW.c


/****************** DEAD CODE BELOW *****************************************/
/****************************************************************************/
#if 0
int BuildContigs(ScaffoldGraphT *graph){
  CDS_CID_t sid;
  /* For each chunk */
  for(sid = 0; sid < GetNumCIScaffoldTs(graph->CIScaffolds); sid++){
    CIScaffoldT *scaffold = GetGraphNode(graph->ScaffoldGraph,sid);
    if(isDeadCIScaffoldT(scaffold))
      continue;
    ContigAScaffold(graph, sid);
  }
  graph->numContigs = GetNumGraphNodes(graph->ContigGraph);
  return TRUE;
}

/***************************************************************************/
// Build contigs for a single scaffold
// ASSUMPTIONS:
//    If the mean positions of two CIs place them overlapping by > Threshhold,
//    then, they indeed overlap and should be contigged
//
int ContigAScaffold(ScaffoldGraphT *graph, CDS_CID_t sid){

    CIScaffoldTIterator CIs;
    CIScaffoldT *scaffold = GetGraphNode(graph->ScaffoldGraph,sid);
    ChunkInstanceT *CI;
    ChunkInstanceT *currCI = NULL;
    ChunkInstanceT *prevCI = NULL;
    ContigEndsT contig;
    int i;
    int32 initialNumElements = scaffold->info.Scaffold.numElements;
    // fprintf(GlobalData->stderrc,"* ContigAScaffold " F_CID "\n", sid);

    if(ContigEnds == NULL){
      ContigEnds = CreateVA_ContigEndsT(10);
    }else{
      ResetContigEndsT(ContigEnds);
    }

    contig.firstCID = contig.lastCID = NULLINDEX;
    contig.firstCI = contig.lastCI = NULL;

    /* First, figure out where the contigs are.  We can't contig them right away, since that
       would be mucking with the data structure we're iterating over */
    InitCIScaffoldTIterator(graph, scaffold, TRUE, FALSE, &CIs);
    /* Initialize CI . . . ELA */
    contig.firstCI = currCI = CI = NextCIScaffoldTIterator(&CIs);
    contig.firstCID = contig.firstCI->id; //GetVAIndex_ChunkInstanceT(graph->ChunkInstances, contig.firstCI);
    AssertPtr(CI);		// There should be at least one CI . . ELA
    if(currCI->offsetAEnd.mean < currCI->offsetBEnd.mean){
      contig.minOffset = currCI->offsetAEnd;
      contig.maxOffset = currCI->offsetBEnd;
    }else{
      contig.maxOffset = currCI->offsetAEnd;
      contig.minOffset = currCI->offsetBEnd;
    }
    contig.count = 0;
    while(CI = NextCIScaffoldTIterator(&CIs)){
      prevCI = currCI;
      currCI = CI;

      contig.count++;
      contig.lastCI = prevCI;
      contig.lastCID = contig.lastCI->id; //GetVAIndex_ChunkInstanceT(graph->ChunkInstances, contig.lastCI);
      // The first CI in the contig must have the minimum offset, by definition
      // subsequent CIs are sorted by LEFTmost coordinate, so we need to track
      // the MAX span (rightmost coordinate)

      {
	CDS_COORD_t actual;

	//#define DEBUG_CONTIG
#ifdef DEBUG_CONTIG
	fprintf(GlobalData->stderrc,"* contig.min = %g contig.max = %g\n",
		contig.minOffset.mean, contig.maxOffset.mean);
#endif
	actual = IntervalsOverlap(contig.minOffset.mean, contig.maxOffset.mean,
                                  currCI->offsetAEnd.mean, currCI->offsetBEnd.mean, -15000);

	if(actual> CGW_DP_MINLEN){
#ifdef DEBUG_CONTIG
	  fprintf(GlobalData->stderrc,
	       "* CI " F_CID " and " F_CID " mean positions overlap by " F_COORD " (%g,%g) (%g,%g)\n",
		prevCI->id,currCI->id, actual, contig.minOffset.mean, 
		contig.maxOffset.mean, currCI->offsetAEnd.mean, 
		currCI->offsetBEnd.mean);
#endif

	  if(currCI->offsetAEnd.mean > contig.maxOffset.mean){
	    contig.maxOffset = currCI->offsetAEnd;
	  }
	  if(currCI->offsetBEnd.mean > contig.maxOffset.mean){
	    contig.maxOffset = currCI->offsetBEnd;
	  }
	}else{
#ifdef DEBUG_CONTIG
	  fprintf(GlobalData->stderrc,"* CI " F_CID " and " F_CID " mean positions GAP by " F_COORD " (%g,%g) (%g,%g) first " F_CID " last " F_CID " \n",
		  prevCI->id,currCI->id, actual, 
		  contig.minOffset.mean,  contig.maxOffset.mean, 
		  currCI->offsetAEnd.mean, currCI->offsetBEnd.mean, 
		  contig.firstCI->id, contig.lastCI->id);
#endif
	  AppendContigEndsT(ContigEnds, &contig);
	  contig.count = 0;
	  contig.firstCI = currCI;
	  contig.firstCID = contig.firstCI->id; //GetVAIndex_ChunkInstanceT(graph->ChunkInstances, contig.firstCI);

	  if(currCI->offsetAEnd.mean < currCI->offsetBEnd.mean){
	    contig.minOffset = currCI->offsetAEnd;
	    contig.maxOffset = currCI->offsetBEnd;
	  }else{
	    contig.maxOffset = currCI->offsetAEnd;
	    contig.minOffset = currCI->offsetBEnd;
	  }
#ifdef DEBUG_CONTIG
	  fprintf(GlobalData->stderrc,"* Reseting contig  firstCI: " F_CID " min:%g max:%g\n",
	    contig.firstCI->id, contig.minOffset.mean, contig.maxOffset.mean);
#endif
	}
      }
    }
    /* Add last contig to the list */
    ++contig.count;
    contig.lastCI = currCI;
    contig.lastCID = contig.lastCI->id; //GetVAIndex_ChunkInstanceT(graph->ChunkInstances, contig.lastCI);
    AppendContigEndsT(ContigEnds, &contig);

    {
      ContigEndsT *ctg = GetContigEndsT(ContigEnds,0);
      ContigT newContig;
      CDS_CID_t firstContig;
      int32 numContigs;

      InitializeContig(&newContig, CONTIG_CGW);
      firstContig = GetNumGraphNodes(graph->ContigGraph);
      numContigs = GetNumContigEndsTs(ContigEnds);

      newContig.flags.bits.isUnique = (scaffold->type == REAL_SCAFFOLD?TRUE:FALSE);
      newContig.flags.bits.cgbType = UU_CGBTYPE;
      newContig.aEndCoord = newContig.bEndCoord = -1;
      newContig.scaffoldID = ctg->firstCI->scaffoldID;
      assert(newContig.scaffoldID != NULLINDEX);
      newContig.edgeHead = NULLINDEX;
      newContig.microhetScore = NULLINDEX;

    /* Now the ContigEnds VA contains the starts/ends of all the contigs */
      for(i = 0; i < numContigs; i++){
	ctg = GetContigEndsT(ContigEnds,i);

	newContig.offsetAEnd = ctg->minOffset;
	newContig.offsetBEnd = ctg->maxOffset;
	newContig.aEndCoord = newContig.bEndCoord = -1;
	newContig.id = firstContig + i;

	// Maybe things have moved by reallocation, refresh this pointer!
	ctg->firstCI = GetGraphNode(graph->RezGraph, ctg->firstCID);
	ctg->lastCI = GetGraphNode(graph->RezGraph, ctg->lastCID);

	if(ctg->firstCI->flags.bits.cgbType == UU_CGBTYPE){
	  if(GetNodeOrient(ctg->firstCI) == A_B){
	    newContig.aEndCoord = ctg->firstCI->aEndCoord;
	  }else{
	    newContig.aEndCoord = ctg->firstCI->bEndCoord;
	  }
	}
	if(ctg->lastCI->flags.bits.cgbType == UU_CGBTYPE){
	  if(GetNodeOrient(ctg->lastCI) == A_B){
	    newContig.bEndCoord = ctg->lastCI->bEndCoord;
	  }else{
	    newContig.bEndCoord = ctg->lastCI->aEndCoord;
	  }
	}

	if(ctg->firstCI->flags.bits.cgbType == UU_CGBTYPE &&
	   ctg->lastCI->flags.bits.cgbType == UU_CGBTYPE){
	  newContig.flags.bits.cgbType = UU_CGBTYPE;
	}else{
	  newContig.flags.bits.cgbType = RR_CGBTYPE;
	}

        ComputeLength(&newContig.bpLength, &(ctg->minOffset), &(ctg->maxOffset));
#ifdef DEBUG_CONTIG
	fprintf(GlobalData->stderrc,"*** newContig.bpLength = %g endLength:%g contig.length = %g (%g,%g)\n",
		newContig.bpLength.mean, 
		newContig.offsetBEnd.mean -newContig.offsetAEnd.mean,
		ctg->maxOffset.mean - ctg->minOffset.mean,
		ctg->minOffset.mean,ctg->maxOffset.mean);
#endif
	// Connect the contig to its consitutent CIs
        newContig.info.Contig.AEndCI = ctg->firstCID;
        newContig.info.Contig.BEndCI = ctg->lastCID;
	newContig.info.Contig.numCI = ctg->count;


	// Disconnect the CIs from their scaffold links
	ctg->firstCI->AEndNext = NULLINDEX;
	ctg->lastCI->BEndNext = NULLINDEX;

	// Connect the contigs within a scaffold with scaffold links 
	if(i != 0)
	  newContig.AEndNext = newContig.id - 1;
	else
	  newContig.AEndNext = NULLINDEX;

	if(i != numContigs - 1)
	  newContig.BEndNext = newContig.id + 1;
	else
	  newContig.BEndNext = NULLINDEX;
	  

#ifdef DEBUG_CONTIG
	fprintf(GlobalData->stderrc,"* Contig " F_CID " at offset %g,%g has length %g +/- %g  nextA:" F_CID "  nextB:" F_CID "  firstCI:" F_CID "  lastCI:" F_CID "\n",
		newContig.id, 
		newContig.offsetAEnd.mean, 
		newContig.offsetBEnd.mean,
		newContig.bpLength.mean, newContig.bpLength.variance,
		newContig.AEndNext, newContig.BEndNext,
		newContig.info.Contig.AEndCI, newContig.info.Contig.BEndCI);
#endif
	AppendGraphNode(graph->ContigGraph, &newContig);

	{
	  ContigTIterator CIs;
	  ChunkInstanceT *CI;
	  int cnt = 0;
	  //#define DEBUG_SCAFFOLD
#ifdef DEBUG_SCAFFOLD
	  fprintf(GlobalData->stderrc,"* Updating CI offsets for Contig " F_CID " relative to (%d,%d)\n",
		  newContig.id, (int) newContig.offsetAEnd.mean, (int) newContig.offsetBEnd.mean);
#endif
	/* Now iterate through the CIs in the Contig, and mark them as belonging to teh contig */
	InitContigTIterator(graph, newContig.id, TRUE, FALSE, &CIs);
	while(CI = NextContigTIterator(&CIs)){

#ifdef DEBUG_SCAFFOLD
	  fprintf(GlobalData->stderrc,"* Marking CI " F_CID " starting at scaffold offsets (%d,%d) contig offset (%d,%d) anext:" F_CID " bnext:" F_CID "\n",
		  CI->id, 
		  (int) CI->offsetAEnd.mean,
		  (int) CI->offsetBEnd.mean,
		  (int) newContig.offsetAEnd.mean,
		  (int) newContig.offsetBEnd.mean,
		  CI->AEndNext, CI->BEndNext);
#endif
	  cnt++;
	  CI->info.CI.contigID = newContig.id;
	  CI->offsetAEnd.mean -= newContig.offsetAEnd.mean;
	  CI->offsetAEnd.variance -= newContig.offsetAEnd.variance;

	  CI->offsetBEnd.mean -= newContig.offsetAEnd.mean;
	  CI->offsetBEnd.variance -= newContig.offsetAEnd.variance;
	  if( CI->offsetAEnd.variance < 0.0){
	    fprintf(GlobalData->stderrc,"* Negative variance on CI (" F_CID ") ->offsetAEnd (%g)\n",
		    CI->id, CI->offsetAEnd.variance);
	    CI->offsetAEnd.variance = 0.0;
	  }
	  fflush(GlobalData->stderrc);
	  if( CI->offsetBEnd.variance < 0.0){
	    fprintf(GlobalData->stderrc,"* Negative variance on CI (" F_CID ") ->offsetBEnd (%g)\n",
		    CI->id, CI->offsetBEnd.variance);
	    CI->offsetBEnd.variance = 0.0;
	  }
	  fflush(GlobalData->stderrc);

#ifdef DEBUG_SCAFFOLD
	  fprintf(GlobalData->stderrc,"* Marking CI " F_CID " as belonging to contig " F_CID " at offsets (%d,%d)\n",
		  CI->id, newContig.id,
		  (int) CI->offsetAEnd.mean,
		  (int) CI->offsetBEnd.mean );
#endif
	}
	  assert(cnt ==  newContig.info.Contig.numCI);

	}

      }
	/* Reset the scaffold, and set it up to hold the collection of contigs */
      scaffold->info.Scaffold.numElements = numContigs;
      scaffold->info.Scaffold.AEndCI = firstContig;
      scaffold->info.Scaffold.BEndCI = firstContig + numContigs - 1;
      scaffold->flags.bits.containsCIs = FALSE;

#ifdef DEBUG
    fprintf(GlobalData->stderrc,"* Scaffold " F_CID " had %d contigs %d CIs aend:" F_CID " bend:" F_CID "\n",
	    sid, (int) GetNumContigEndsTs(ContigEnds), scaffold->numElements,
	    scaffold->info.Scaffold.AEndCI, scaffold->info.Scaffold.BEndCI);
#endif
    }
    return TRUE;
}
#endif
